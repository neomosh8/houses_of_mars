<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mars Runner</title>
  <link rel="stylesheet" href="style.css">
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="login-container" class="login-container">
    <div class="login-box">
      <input type="email" id="login-email" placeholder="Email" />
      <button id="send-code">Send Code</button>
      <div id="code-section" class="hidden">
        <input type="text" id="login-code" placeholder="Code" />
        <button id="verify-code">Verify</button>
      </div>
      <div id="login-error"></div>
    </div>
  </div>
  <div id="loading-container" class="loading-container hidden">
    <div id="loading-tip" class="loading-tip"></div>
    <div class="loading-progress-container">
      <div class="loading-box">
        <div id="loading-bar" class="loading-bar"></div>
      </div>
      <div id="loading-text" class="loading-text"></div>
      <div id="loading-details" class="loading-details"></div>
    </div>
    <img id="loading-image" class="loading-image hidden" />
    <video id="intro-video" class="intro-video hidden" src="intro.mp4" preload="auto" autoplay muted playsinline></video>
  </div>
  <div id="money-display">Money: 0</div>
  <div id="status-panel">
    <div class="stat"><img id="health-img" /></div>
    <div class="stat"><img id="hydration-img" /></div>
    <div class="stat"><img id="oxygen-img" /></div>
  </div>
  <div id="low-oxygen-overlay"></div>
  <div id="death-overlay">
    <div>You died</div>
    <button id="respawn-btn">Respawn for 1000</button>
  </div>
  <div id="institution-panel" class="side-panel panel">
    <div class="panel-tab">Institutions</div>
    <div class="panel-content" id="institution-content"></div>
  </div>
  <div id="institution-popup" class="panel" tabindex="0">
    <div id="popup-close" >X</div>
    <div id="popup-info">
      <div id="popup-owner"></div>
      <div id="popup-resources"></div>
      <div id="popup-workforce-carousel" ></div>
    </div>
    <div id="popup-workforce" class="hidden">
      <div id="workforce-container" ></div>
    </div>
    <div id="popup-chat" class="hidden">
      <div id="chat-container"></div>
      <div id="chat-input-row">
        <input id="chat-input" type="text" placeholder="Type message" />
        <button id="chat-send">Send</button>
      </div>
    </div>
    <div id="popup-proposals" class="hidden">
      <div id="proposals-container"></div>
    </div>
    <div id="popup-weapons" class="hidden">
      <div id="weapons-container"></div>
    </div>
          <div class="popup-actions">
      <button id="info-tab-btn">Info</button>
      <button id="workforce-tab-btn">See Applicants</button>
      <button id="chat-tab-btn">Chat</button>
      <button id="proposals-tab-btn">Proposals</button>
      <button id="weapons-tab-btn">Weapon Catalogue</button>
    </div>
  </div>
  <!-- Resource Breakdown Popup -->
  <div id="resource-breakdown-popup" class="panel resource-popup" style="display:none;">
    <div id="breakdown-close" class="popup-close">√ó</div>
    <h2>Resource Breakdown</h2>

    <!-- Aggregated Overview -->
    <div class="breakdown-section">
      <h3>Net Resource Flow</h3>
      <div id="net-flow-container" class="net-flow-grid">
        <!-- Will be populated dynamically -->
      </div>
    </div>

    <!-- Detailed Breakdown -->
    <div class="breakdown-section">
      <h3>Top Producers & Consumers</h3>
      <div id="breakdown-tabs" class="breakdown-tabs">
        <button class="tab-btn active" data-resource="hydration">üíß Hydration</button>
        <button class="tab-btn" data-resource="oxygen">üå¨Ô∏è Oxygen</button>
        <button class="tab-btn" data-resource="health">‚ù§Ô∏è Health</button>
        <button class="tab-btn" data-resource="money">üí∞ Money</button>
      </div>
      <div id="breakdown-details" class="breakdown-details">
        <!-- Will be populated dynamically -->
      </div>
    </div>
  </div>
  <div id="partner-form" class="panel" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:10px;gap:4px;flex-direction:column;">
    <label>Total Shares <input id="partner-total" type="number" value="10" min="1"></label>
    <label>Share Price <input id="partner-price" type="number" value="10" min="1"></label>
    <label>My Shares <input id="partner-my" type="number" value="1" min="1"></label>
    <button id="partner-save">Save</button>
  </div>
  <div id="referendum-form" class="panel" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:10px;gap:6px;flex-direction:column;">
    <select id="referendum-type">
      <option value="candidate">Board Candidate</option>
      <option value="fire">Remove Board Member</option>
      <option value="policy">Open Policy</option>
    </select>
    <div id="candidate-fields">
      <input id="candidate-email" type="text" placeholder="Candidate Email">
      <input id="candidate-name" type="text" placeholder="Candidate Name">
    </div>
    <div id="fire-fields" style="display:none;">
      <select id="fire-email"></select>
    </div>
    <div id="policy-fields" style="display:none;">
      <input id="policy-text" type="text" placeholder="Policy Text">
    </div>
    <button id="referendum-submit">Submit</button>
  </div>
  <div id="policy-form" class="panel" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:10px;gap:6px;flex-direction:column;">
    <input id="policy-title" type="text" placeholder="Policy Title">
    <textarea id="policy-desc" placeholder="Policy Description" rows="4" style="width:200px;"></textarea>
    <button id="policy-save">Save</button>
  </div>
  <div id="worker-profile-overlay" class="worker-profile-overlay hidden">
    <div class="worker-profile">
      <div class="profile-close" id="profile-close">√ó</div>
      <div class="profile-header">
        <img id="profile-image" class="profile-image" src="" alt="">
        <div class="profile-info">
          <h2 id="profile-name"></h2>
          <h3 id="profile-role"></h3>
          <div class="profile-stats">
            <div class="wage-info">üí∞ Wage: $<span id="profile-wage"></span>/day</div>
            <div class="resource-info">
              <span class="resource-item">üíß Hydration: <span id="profile-hydration"></span></span>
              <span class="resource-item">üå¨Ô∏è Oxygen: <span id="profile-oxygen"></span></span>
              <span class="resource-item">‚ù§Ô∏è Health: <span id="profile-health"></span></span>
            </div>
          </div>
        </div>
      </div>
      <div class="profile-content">
        <div class="profile-section">
          <h4>Backstory</h4>
          <div id="profile-backstory"></div>
        </div>
        <div class="profile-section">
          <h4>Resume</h4>
          <div id="profile-resume"></div>
        </div>
      </div>
      <div class="profile-actions">
        <button id="profile-hire-btn" class="profile-btn hire-btn">Hire</button>
        <button id="profile-fire-btn" class="profile-btn fire-btn">Fire</button>
      </div>
    </div>
  </div>

  <div id="planethall-popup" class="panel" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:700px;max-height:80vh;padding:20px;">
    <div id="planethall-close" style="cursor:pointer;position:absolute;top:10px;right:10px;font-size:20px;">‚úï</div>
    <h2 style="text-align:center;margin-bottom:20px;">Mars Planet Hall</h2>
    <div class="planethall-tabs">
      <button class="hall-tab active" data-section="board">Governing Board</button>
      <button class="hall-tab" data-section="referendum">Referendum</button>
      <button class="hall-tab" data-section="chat">Public Chat</button>
      <button class="hall-tab" data-section="policies">Policies</button>
    </div>
    <div id="hall-board" class="hall-section">
      <h3>Mars Governing Board</h3>
      <div id="board-members"></div>
    </div>
    <div id="hall-referendum" class="hall-section" style="display:none;">
      <h3>Referendum</h3>
      <button id="request-referendum">Request Referendum</button>
      <div id="active-referendum"></div>
      <div id="referendum-history"></div>
    </div>
    <div id="hall-chat" class="hall-section" style="display:none;">
      <h3>Public Chat</h3>
      <div id="hall-chat-messages"></div>
      <div style="display:flex;gap:4px;margin-top:8px;">
        <input id="hall-chat-input" type="text" style="flex:1;padding:4px;" placeholder="Type message...">
        <button id="hall-chat-send">Send</button>
      </div>
    </div>
    <div id="hall-policies" class="hall-section" style="display:none;">
      <h3>Policies</h3>
      <button id="new-policy-btn" style="display:none;">New Policy</button>
      <div id="policies-list"></div>
    </div>
  </div>
  <script type="module">

  const DEBUG_LOG = true;
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
  import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
  import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
  import { renderProposals } from './proposals.js';
  import { renderDefProposals } from './defProposals.js';

  import { preloadAssets, assetsInCache } from "./preloadAssets.js";

  let playerEmail = null;
  let playerMoney = 0;
  let startPosition = [70, 100, -50];

  const SLIDES = ['slide1.png', 'slide2.png', 'slide3.png'];
  const SLIDE_TIPS = [
    'Stay healthy to survive the harsh environment.',
    'Efficient transport keeps the colony running.',
    'Handle chemicals with extreme caution.'
  ];
  const SLIDE_DURATION = 3000; // ms
  let slideIndex = 0;
  let slideTimer = null;
  let slideshowAudio = null;

  function playAudioWithUserGesture(audio) {
    if (!audio) return;
    const attempt = () => {
      if (!audio.paused) {
        document.removeEventListener('click', attempt);
        document.removeEventListener('keydown', attempt);
        return;
      }
      audio.play().then(() => {
        document.removeEventListener('click', attempt);
        document.removeEventListener('keydown', attempt);
      }).catch(() => {/* ignore until next user gesture */});
    };
    attempt();
    document.addEventListener('click', attempt);
    document.addEventListener('keydown', attempt);
  }


  function startSlideshow() {
    const img = document.getElementById('loading-image');
    const tipEl = document.getElementById('loading-tip');
    if (!img) return;
    img.classList.remove('hidden');
    img.src = SLIDES[0];
    if (tipEl) tipEl.textContent = SLIDE_TIPS[0] || '';
    slideIndex = 0;
    if (!slideshowAudio) {
      slideshowAudio = new Audio('intro_music.mp3');
      slideshowAudio.loop = true;
    }
    playAudioWithUserGesture(slideshowAudio);

    slideTimer = setInterval(() => {
      slideIndex = (slideIndex + 1) % SLIDES.length;
      img.src = SLIDES[slideIndex];
      if (tipEl) tipEl.textContent = SLIDE_TIPS[slideIndex] || '';
    }, SLIDE_DURATION);
  }

  function stopSlideshow() {
    if (slideTimer) clearInterval(slideTimer);
    slideTimer = null;
    const tipEl = document.getElementById('loading-tip');
    if (tipEl) tipEl.textContent = '';
  }

  async function playIntroSequence() {
    stopSlideshow();
    const img = document.getElementById('loading-image');
    if (img) {
      img.src = SLIDES[SLIDES.length - 1];
    }
    await new Promise(r => setTimeout(r, SLIDE_DURATION));
    const video = document.getElementById('intro-video');
    if (video) {
      video.classList.remove('hidden');
      try { await video.play(); } catch (e) { console.error('Video play failed', e); }
      await new Promise(res => video.onended = res);
      video.classList.add('hidden');
    }
    if (slideshowAudio) {
      slideshowAudio.pause();
      slideshowAudio.currentTime = 0;
    }
    const loaderEl = document.getElementById('loading-container');
    loaderEl.classList.add('hidden');
    loaderEl.style.display = 'none';
  }

const icons = {
  health_full: 'healthfull.png',
  health_half: 'healthhalf.png',
  health_low: 'healthlow.png',
  hydration_full: 'watfull.png',
  hydration_half: 'wathalf.png',
  hydration_low: 'watlow.png',
  oxygen_full: 'o2full.png',
  oxygen_half: 'o2half.png',
  oxygen_low: 'o2low.png'
};

  function createPlaceholder(scale = 1, color = 0x5555ff) {
    const geom = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.scale.setScalar(scale);
    return mesh;
  }

  // Load a GLB model using the Cache API if available. Falls back to
  // fetching from the network and stores the result in the cache for
  // future use.
  async function loadGLTFCached(url) {
    const absolute = url.startsWith('http://') || url.startsWith('https://')
      ? url
      : new URL(url, window.location.href).href;
    let cache = null;
    try {
      cache = await caches.open('asset-cache');
      const cached = await cache.match(absolute);
      if (cached) {
        const arrayBuffer = await cached.arrayBuffer();
        return await new Promise((resolve, reject) => {
          new GLTFLoader().parse(arrayBuffer, '', resolve, reject);
        });
      }
    } catch (e) {
      console.warn('Cache lookup failed for', url, e);
      cache = null;
    }

    const response = await fetch(absolute);
    if (!response.ok) throw new Error(`Failed to fetch ${url}: ${response.status}`);
    const clone = response.clone();
    const arrayBuffer = await response.arrayBuffer();

    if (cache) {
      try {
        await cache.put(absolute, clone);
      } catch (e) {
        console.warn('Cache store failed for', url, e);
      }
    }

    return await new Promise((resolve, reject) => {
      new GLTFLoader().parse(arrayBuffer, '', resolve, reject);
    });
  }

  // Create a 2D ground footprint (X/Z) for an object. This footprint is used
  // for all collision checks so that only horizontal space on the terrain is
  // considered.
  function createBuildingFootprint(obj) {
    obj.updateWorldMatrix(true, false);
    const box = new THREE.Box3();
    obj.traverse(node => {
      if (node.isMesh && node.geometry) {
        const geom = node.geometry;
        if (!geom.boundingBox) geom.computeBoundingBox();
        const bb = geom.boundingBox.clone();
        bb.applyMatrix4(node.matrixWorld);
        box.expandByPoint(bb.min);
        box.expandByPoint(bb.max);
      }
    });
    return {
      minX: box.min.x,
      maxX: box.max.x,
      minZ: box.min.z,
      maxZ: box.max.z,
    };
  }

  // Update an existing footprint with a new object's bounds
  function updateBuildingFootprint(fp, obj) {
    obj.updateWorldMatrix(true, false);
    const box = new THREE.Box3();
    obj.traverse(node => {
      if (node.isMesh && node.geometry) {
        const geom = node.geometry;
        if (!geom.boundingBox) geom.computeBoundingBox();
        const bb = geom.boundingBox.clone();
        bb.applyMatrix4(node.matrixWorld);
        box.expandByPoint(bb.min);
        box.expandByPoint(bb.max);
      }
    });
    fp.minX = box.min.x;
    fp.maxX = box.max.x;
    fp.minZ = box.min.z;
    fp.maxZ = box.max.z;
  }

  // Test if a THREE.Sphere intersects the ground footprint
  function sphereIntersectsFootprint(fp, sphere) {
    const x = sphere.center.x;
    const z = sphere.center.z;
    const dx = Math.max(fp.minX - x, 0, x - fp.maxX);
    const dz = Math.max(fp.minZ - z, 0, z - fp.maxZ);
    return dx * dx + dz * dz <= sphere.radius * sphere.radius;
  }

  function printGLTFHierarchy(obj, prefix = '') {
    if (!obj || typeof obj.traverse !== 'function') return;
    console.log(prefix + (obj.name || obj.type));
    obj.children?.forEach(child => printGLTFHierarchy(child, prefix + '  '));
  }

  function addPointLightsFromGLTF(gltf) {
  if (!gltf) return;
  const root = gltf.scene || (gltf.scenes && gltf.scenes[0]);
  if (!root || typeof root.traverse !== 'function') return;

  // (Optional) dump out the hierarchy for debugging:
  if (DEBUG_LOG) printGLTFHierarchy(root);

  root.traverse(node => {
    if (node.isLight) {
      // ‚Üê clone() instead of reparenting the exact node
      scene.add(node.clone());
    }
  });
}


  const healthImg = document.getElementById('health-img');
  const hydrationImg = document.getElementById('hydration-img');
  const oxygenImg = document.getElementById('oxygen-img');
  const lowOxygenOverlay = document.getElementById('low-oxygen-overlay');
  const deathOverlay = document.getElementById('death-overlay');
  const respawnBtn = document.getElementById('respawn-btn');

  let health = 1000;
  let hydration = 1000;
  let oxygen = 1000;
  let dead = false;

  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  // Resource tracking system
  const resourceTracking = {
    sources: {
      institutions: new Map(), // id -> { name, owner, effects }
      workforce: new Map(),    // id:workerIndex -> { name, institutionId, effects }
      activity: { hydration: 0, oxygen: 0, health: 0, money: 0 },
      proposals: new Map()     // placeholder for future use
    },

    trackActivity(hydrationRate, oxygenRate) {
      this.sources.activity.hydration = -hydrationRate;
      this.sources.activity.oxygen = -oxygenRate;
    },

    updateInstitution(id, name, owner, effects, share) {
      const factor = share == null ? 1 : share;
      const scaledEffects = {};
      for (const [key, value] of Object.entries(effects)) {
        scaledEffects[key] = value * factor;
      }
      if (this.sources.institutions.has(id)) {
        const existing = this.sources.institutions.get(id);
        for (const [k, val] of Object.entries(scaledEffects)) {
          existing.effects[k] = (existing.effects[k] || 0) + val;
        }
      } else {
        this.sources.institutions.set(id, { name, owner, effects: scaledEffects });
      }
    },

    updateWorkforce(institutionId, workerIndex, worker) {
      const key = `${institutionId}:${workerIndex}`;
      const effects = Object.assign({}, worker.effects || {});
      if (worker.wage) {
        effects.money = (effects.money || 0) - worker.wage;
      }
      this.sources.workforce.set(key, {
        name: worker.name,
        role: worker.role,
        institutionId,
        effects
      });
    },

    calculateRates() {
      const rates = {
        hydration: { total: 0, producers: [], consumers: [] },
        oxygen: { total: 0, producers: [], consumers: [] },
        health: { total: 0, producers: [], consumers: [] },
        money: { total: 0, producers: [], consumers: [] }
      };

      this.sources.institutions.forEach((inst, id) => {
        for (const [resource, value] of Object.entries(inst.effects)) {
          if (typeof value === 'number' && value !== 0) {
            rates[resource].total += value;
            const item = {
              name: inst.name,
              source: `Institution (${inst.owner})`,
              value: value,
              id: id
            };
            if (value > 0) rates[resource].producers.push(item);
            else rates[resource].consumers.push(item);
          }
        }
      });

      this.sources.workforce.forEach((worker, key) => {
        for (const [resource, value] of Object.entries(worker.effects)) {
          if (typeof value === 'number' && value !== 0) {
            rates[resource].total += value;
            const inst = institutionDataMap[worker.institutionId];
            const item = {
              name: `${worker.name} (${worker.role})`,
              source: inst ? inst.name : 'Unknown',
              value: value,
              id: key
            };
            if (value > 0) rates[resource].producers.push(item);
            else rates[resource].consumers.push(item);
          }
        }
      });

      for (const [resource, value] of Object.entries(this.sources.activity)) {
        if (value !== 0) {
          rates[resource].total += value;
          const item = {
            name: 'Character Activity',
            source: isRunning ? 'Running' : isMovingForward ? 'Walking' : 'Idle',
            value: value
          };
          if (value > 0) rates[resource].producers.push(item);
          else rates[resource].consumers.push(item);
        }
      }

      for (const resource of ['hydration', 'oxygen', 'health', 'money']) {
        rates[resource].producers.sort((a, b) => b.value - a.value).splice(10);
        rates[resource].consumers.sort((a, b) => a.value - b.value).splice(10);
      }

      return rates;
    }
  };

  function updateResourceTracking() {
    resourceTracking.sources.institutions.clear();
    resourceTracking.sources.workforce.clear();

    ownedInstitutions.forEach(inst => {
      const instData = institutionDataMap[inst.id];
      if (instData && !instData.destroyed) {
        const share = inst.factor || 1;
        const effects = {};
        ['hydration', 'oxygen', 'health', 'money'].forEach(k => {
          if (typeof inst[k] === 'number') effects[k] = inst[k];
        });
        resourceTracking.updateInstitution(
          inst.id,
          instData.name,
          instData.owner,
          effects,
          share
        );
      }
    });

    Object.values(institutionDataMap).forEach(inst => {
      if (inst.owner === playerEmail && Array.isArray(inst.workforce)) {
        inst.workforce.forEach((worker, idx) => {
          if (worker.effects) resourceTracking.updateWorkforce(inst.id, idx, worker);
        });
      }
    });

    const hydrationRate = isMovingForward ? (isRunning ? 0.05 : 0.05) : 0.02;
    const oxygenRate = isMovingForward ? 0.02 : 0.005;
    resourceTracking.trackActivity(hydrationRate, oxygenRate);
  }

  function showResourceBreakdown() {
    updateResourceTracking();
    const rates = resourceTracking.calculateRates();

    const netFlowContainer = document.getElementById('net-flow-container');
    netFlowContainer.innerHTML = '';

    const resourceInfo = {
      hydration: { icon: 'üíß', name: 'Hydration' },
      oxygen: { icon: 'üå¨Ô∏è', name: 'Oxygen' },
      health: { icon: '‚ù§Ô∏è', name: 'Health' },
      money: { icon: 'üí∞', name: 'Money' }
    };

    for (const [resource, info] of Object.entries(resourceInfo)) {
      const rate = rates[resource];
      const card = document.createElement('div');
      card.className = 'resource-flow-card';

      const flowClass = rate.total > 0 ? 'flow-positive' : rate.total < 0 ? 'flow-negative' : 'flow-neutral';
      const sign = rate.total > 0 ? '+' : '';

      card.innerHTML = `
        <h4>${info.icon} ${info.name}</h4>
        <div class="flow-value ${flowClass}">${sign}${rate.total.toFixed(2)}/cycle</div>
        <div class="flow-breakdown">
          <div>Producers: ${rate.producers.length}</div>
          <div>Consumers: ${rate.consumers.length}</div>
        </div>
      `;

      netFlowContainer.appendChild(card);
    }

    showResourceDetails('hydration');

    document.getElementById('resource-breakdown-popup').style.display = 'block';
  }

  function showResourceDetails(resource) {
    updateResourceTracking();
    const rates = resourceTracking.calculateRates();
    const data = rates[resource];

    const detailsContainer = document.getElementById('breakdown-details');
    detailsContainer.innerHTML = `
      <div class="producers-list">
        <h4>Top Producers</h4>
        ${data.producers.map(item => `
          <div class="breakdown-item">
            <span class="breakdown-item-name">
              ${item.name}
              <span class="breakdown-item-source">${item.source}</span>
            </span>
            <span class="breakdown-item-value flow-positive">+${item.value.toFixed(2)}</span>
          </div>
        `).join('') || '<div class="breakdown-item">None</div>'}
      </div>
      <div class="consumers-list">
        <h4>Top Consumers</h4>
        ${data.consumers.map(item => `
          <div class="breakdown-item">
            <span class="breakdown-item-name">
              ${item.name}
              <span class="breakdown-item-source">${item.source}</span>
            </span>
            <span class="breakdown-item-value flow-negative">${item.value.toFixed(2)}</span>
          </div>
        `).join('') || '<div class="breakdown-item">None</div>'}
      </div>
    `;

    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.resource === resource);
    });
  }

  document.getElementById('status-panel').addEventListener('click', showResourceBreakdown);

  document.getElementById('breakdown-close').addEventListener('click', () => {
    document.getElementById('resource-breakdown-popup').style.display = 'none';
  });

  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      showResourceDetails(btn.dataset.resource);
    });
  });

  setInterval(updateResourceTracking, 5000);

  function fadeSwap(img, src) {
    if (img.dataset.current === src) return;
    img.style.opacity = 0;
    setTimeout(() => {
      img.src = src;
      img.dataset.current = src;
      img.style.opacity = 1;
    }, 100);
  }

function updateStatImages() {
  // Use percentage calculation with better boundaries
  const healthPct = (health / 100) * 100;  // Convert to 0-100 percentage
  const hydPct = (hydration / 100) * 100;
  const oxyPct = (oxygen / 100) * 100;

  // Health image logic
  let healthSrc = icons.health_low;
  if (healthPct >= 66) healthSrc = icons.health_full;      // 66-100%
  else if (healthPct >= 33) healthSrc = icons.health_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(healthImg, healthSrc);

  // Hydration image logic
  let hydSrc = icons.hydration_low;
  if (hydPct >= 66) hydSrc = icons.hydration_full;      // 66-100%
  else if (hydPct >= 33) hydSrc = icons.hydration_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(hydrationImg, hydSrc);

  // Oxygen image logic
  let oxySrc = icons.oxygen_low;
  if (oxyPct >= 66) oxySrc = icons.oxygen_full;      // 66-100%
  else if (oxyPct >= 33) oxySrc = icons.oxygen_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(oxygenImg, oxySrc);

  // Debug logging to help track issues
}

  function updateMoneyDisplay() {
    document.getElementById('money-display').textContent = `Money: ${playerMoney}`;
    updateInstitutionTiles();
  }

  respawnBtn.onclick = () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'respawn' }));
    }
  };

  async function autoLogin(email) {
    const loaderEl = document.getElementById('loading-container');
    try {
      const res = await fetch('/api/state/' + encodeURIComponent(email));
      if (!res.ok) throw new Error('state');
      const data = await res.json();
      startPosition = data.position;
      playerMoney = data.money || 0;
      health = data.health || 1000;
      hydration = data.hydration || 1000;
      oxygen = data.oxygen || 1000;
      updateStatImages();
      playerEmail = email;
      document.getElementById('login-container').style.display = 'none';
      loaderEl.classList.remove('hidden');
      loaderEl.style.display = 'flex';
      document.getElementById('loading-bar').style.width = '0%';
      const cached = await assetsInCache(PRELOAD_ASSETS);
      if (!cached) {
        document.getElementById('loading-text').textContent = 'Fetching files list...';
        startSlideshow();
        await preloadAssets(
          PRELOAD_ASSETS,
          p => {
            document.getElementById('loading-bar').style.width = `${Math.floor(p * 100)}%`;
          },
          msg => {
            document.getElementById('loading-text').textContent = msg;
          }
        );
        await playIntroSequence();
      } else {
        document.getElementById('loading-text').textContent = 'Using cached assets...';
        document.getElementById('loading-bar').style.width = '100%';
        loaderEl.classList.add('hidden');
        loaderEl.style.display = 'none';
      }
      initNetwork();
      updateMoneyDisplay();
      startGame();
      return true;
    } catch (e) {
      console.error('autoLogin failed:', e);
      loaderEl.classList.add('hidden');
      loaderEl.style.display = 'none';
      document.getElementById('login-container').style.display = 'flex';
      return false;
    }
  }

  const stored = localStorage.getItem('playerEmail');
  if (stored) {
    (async () => {
      try {
        await autoLogin(stored);
      } catch (e) {
        console.error('Stored login failed:', e);
      }
    })();
  }

    // --- Institution placement ---
  const institutions = [
    {
      name: 'WatOx',
      url: 'watox.glb',
      thumbnail: 'watox.png',
      scale: 1,
      price: 150,
      effects: { hydration: 0.5, oxygen: 0.5 },
      animated: false
    },
    {
      name: 'agriFood',
      url: 'agriFood.glb',
      thumbnail: 'agriFood.png',
      scale: 1,
      price: 200,
      effects: { health: 0.2 },
      animated: false
    },
    {
      name: 'Depot',
      url: 'base.glb',
      thumbnail: 'transport.png',
      scale: 0.5,
      price: 150,
      effects: { money: 1 },
      animated: true
    },
    {
      name: 'Defence Base',
      url: 'defbase.glb',
      thumbnail: 'defbase.png',
      scale: 10,
      price: 300,
      effects: {},
      animated: false
    },
    {
      name: 'Planet Hall',
      url: 'hall.glb',
      thumbnail: 'planethall.png',
      scale: 30,
      price: 0,
      effects: {},
      animated: false,
      isPlanetHall: true
    }
  ];

  const institutionAudioFiles = {
    'WatOx': 'watox.mp3',
    'agriFood': 'agrifood.mp3',
    'Depot': 'depot.mp3',
    'Defence Base': 'defence_base.mp3'
  };
  const weaponAudioFiles = {
    laser: "laser.mp3",
    bullet: "bullet.mp3",
    missile: "missile.mp3",
    drone: "drone.mp3",
    kamikaze: "kamikaze.mp3"
  };

const PRELOAD_ASSETS = [
  "watox.glb","agrifood.glb","base.glb","defbase.glb","character.glb","flag.glb",
  "planethall.glb",
  "walking.mp3"
];
// Debug helper for remote server issues
console.log('Current location:', window.location.href);
console.log('Asset URLs will resolve to:', PRELOAD_ASSETS.map(url => new URL(url, window.location.href).href));

// Check if we're on HTTPS and warn about mixed content
if (window.location.protocol === 'https:') {
  console.warn('Site is on HTTPS - ensure all assets are also HTTPS to avoid mixed content issues');
}
  const panel = document.getElementById('institution-panel');
  const panelTab = panel.querySelector('.panel-tab');
  const panelContent = document.getElementById('institution-content');
  panelTab.addEventListener('click', () => {
    panel.classList.toggle('open');
  });

  const institutionTiles = [];
  const ownedInstitutions = [];
  function addInstitutionEffects(id, effects) {
    if (!effects || typeof effects !== 'object') return;
    const inst = institutionDataMap[id];
    const share = (inst && inst.shares && inst.shares[playerEmail]) || 0;
    const total = (inst && inst.totalShares) || 1;
    const factor = total ? share / total : 0;
    let entry = ownedInstitutions.find(e => e.id === id);
    if (!entry) {
      entry = { id, factor };
      ownedInstitutions.push(entry);
    } else {
      entry.factor = factor;
    }
    for (const [k, v] of Object.entries(effects)) {
      if (typeof v === 'number') entry[k] = (entry[k] || 0) + v;
    }
  }

  function removeInstitutionEffects(id) {
    for (let i = ownedInstitutions.length - 1; i >= 0; i--) {
      if (ownedInstitutions[i].id === id) ownedInstitutions.splice(i, 1);
    }
  }
  const INSTITUTION_INTERVAL_FRAMES = 60;
  let institutionFrame = 0;
  institutions.forEach(inst => {
    if (inst.isPlanetHall) return;
    const tile = document.createElement('div');
    tile.className = 'institution-tile';
    const img = document.createElement('img');
    img.src = inst.thumbnail;
    img.alt = inst.name;
    tile.appendChild(img);
    const label = document.createElement('div');
    label.textContent = `${inst.name} ($${inst.price})`;
    tile.appendChild(label);
    const overlay = document.createElement('div');
    overlay.className = 'institution-overlay';
    overlay.innerHTML = '<div>Not enough money</div><button>Request partners</button>';
    const reqBtn = overlay.querySelector('button');
    reqBtn.onclick = e => { e.stopPropagation(); openPartnerForm(inst); };
    tile.appendChild(overlay);
    tile.addEventListener('click', () => {
      if (playerMoney >= inst.price) {
        selectInstitution(inst);
      }
    });
    panelContent.appendChild(tile);
    institutionTiles.push({ tile, overlay, inst });
  });

  function updateInstitutionTiles() {
    institutionTiles.forEach(t => {
      if (playerMoney >= t.inst.price) {
        t.overlay.style.display = 'none';
      } else {
        t.overlay.style.display = 'flex';
      }
    });
  }

  function openPartnerForm(inst) {
    const form = document.getElementById('partner-form');
    form.style.display = 'flex';
    document.getElementById('partner-total').value = 10;
    document.getElementById('partner-price').value = Math.ceil(inst.price / 10);
    document.getElementById('partner-my').value = 1;
    placingApplication = false;
    applicationInfo = null;
    const save = document.getElementById('partner-save');
    save.onclick = e => {
      e.stopPropagation();
      const total = parseInt(document.getElementById('partner-total').value) || 1;
      const price = parseInt(document.getElementById('partner-price').value) || 1;
      const mine = parseInt(document.getElementById('partner-my').value) || 0;
      applicationInfo = { totalShares: total, sharePrice: price, myShares: mine };
      form.style.display = 'none';
      placingApplication = true;
      selectInstitution(inst);
    };
  }

  function openBuySharesForm(inst) {
    const form = document.getElementById('partner-form');
    form.style.display = 'flex';
    document.getElementById('partner-total').value = inst.totalShares;
    document.getElementById('partner-price').value = inst.sharePrice;
    document.getElementById('partner-my').value = 1;
    const save = document.getElementById('partner-save');
    save.onclick = e => {
      e.stopPropagation();
      const shares = parseInt(document.getElementById('partner-my').value) || 0;
      form.style.display = 'none';
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'buyShares', id: inst.id, shares }));
      }
    };
  }

  let hallFormOpen = false;
  let hallEscHandler = null;

  function closeHallForms() {
    document.getElementById('referendum-form').style.display = 'none';
    document.getElementById('policy-form').style.display = 'none';
    hallFormOpen = false;
    if (hallEscHandler) {
      document.removeEventListener('keydown', hallEscHandler);
      hallEscHandler = null;
    }
  }

  function openReferendumForm() {
    closeHallForms();
    const form = document.getElementById('referendum-form');
    form.style.display = 'flex';
    hallFormOpen = true;
    updateReferendumFields();
    hallEscHandler = e => { if (e.key === 'Escape') closeHallForms(); };
    document.addEventListener('keydown', hallEscHandler);
  }

  function openPolicyForm() {
    closeHallForms();
    const form = document.getElementById('policy-form');
    form.style.display = 'flex';
    document.getElementById('policy-title').value = '';
    document.getElementById('policy-desc').value = '';
    hallFormOpen = true;
    hallEscHandler = e => { if (e.key === 'Escape') closeHallForms(); };
    document.addEventListener('keydown', hallEscHandler);
  }

  function updateReferendumFields() {
    const type = document.getElementById('referendum-type').value;
    document.getElementById('candidate-fields').style.display = type === 'candidate' ? 'block' : 'none';
    document.getElementById('fire-fields').style.display = type === 'fire' ? 'block' : 'none';
    document.getElementById('policy-fields').style.display = type === 'policy' ? 'block' : 'none';
    if (type === 'fire') {
      const sel = document.getElementById('fire-email');
      sel.innerHTML = '';
      currentBoardMembers.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.email;
        opt.textContent = m.name;
        sel.appendChild(opt);
      });
    }
  }

  let ghostInstitution = null;
  let ghostMixer = null;
  let placingInstitution = false;
  let currentInstitution = null;
  let institutionPopupOpen = false;
  let placingApplication = false;
  let applicationInfo = null;

  async function selectInstitution(inst) {
    if (ghostInstitution) {
      scene.remove(ghostInstitution);
      ghostInstitution = null;
      if (ghostMixer) {
        ghostMixer.stopAllAction();
        ghostMixer = null;
      }
    }
    try {
      const gltf = await loadGLTFCached(inst.url);
      const root = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!root) return;
      ghostInstitution = root;
      addPointLightsFromGLTF(gltf);
      ghostInstitution.scale.setScalar(inst.scale || 1);
      const box = new THREE.Box3().setFromObject(ghostInstitution);
      const size = box.getSize(new THREE.Vector3());
      ghostInstitution.userData.radius = Math.max(size.x, size.z) * 0.6;
      ghostInstitution.userData.safeDistance = Math.max(size.x, size.z) * 1.5;
      ghostInstitution.traverse(o => {
        if (o.isMesh) {
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0.5;
          o.castShadow = true;
          o.receiveShadow = true;
        }
      });
      if (inst.animated && gltf.animations && gltf.animations.length > 0) {
        ghostMixer = new THREE.AnimationMixer(ghostInstitution);
        gltf.animations.forEach(a => ghostMixer.clipAction(a).play());
      }
      scene.add(ghostInstitution);
      placingInstitution = true;
      currentInstitution = inst;
    } catch (e) {
      console.error('Failed to load institution model:', e);
    }
  }

  function handleClick(event) {
    if (institutionPopupOpen || hallFormOpen) return;
    if (placingInstitution && ghostInstitution && currentInstitution) {
      const cost = typeof currentInstitution.price === 'number' ? currentInstitution.price : 0;
      if (!placingApplication && playerMoney < cost) {
        alert('Not enough money');
        return;
      }
    } else if (currentInstitution && !placingApplication && playerMoney < currentInstitution.price) {
      // For regular placement, check full price
      alert('Not enough money');
      return;
    }
    if (placingInstitution && ghostInstitution && currentInstitution) {
      const box = new THREE.Box3().setFromObject(ghostInstitution);
      const fp = createBuildingFootprint(ghostInstitution);
      const newGround = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
      // Align the bottom of the model with the ground
      const offsetY = box.min.y - ghostInstitution.position.y;
      const targetY = newGround - offsetY;

      let data;
      if (placingApplication && applicationInfo) {
        data = {
          type: 'addInstitutionApplication',
          name: currentInstitution.name,
          position: [ghostInstitution.position.x, targetY, ghostInstitution.position.z],
          rotation: ghostInstitution.rotation.y,
          scale: currentInstitution.scale,
          totalShares: applicationInfo.totalShares,
          sharePrice: applicationInfo.sharePrice,
          myShares: applicationInfo.myShares
        };
      } else {
        data = {
          type: 'addInstitution',
          name: currentInstitution.name,
          position: [ghostInstitution.position.x, targetY, ghostInstitution.position.z],
          rotation: ghostInstitution.rotation.y,
          scale: currentInstitution.scale
        };
      }
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(data));
      }
      scene.remove(ghostInstitution);
      ghostInstitution = null;
      if (ghostMixer) {
        ghostMixer.stopAllAction();
        ghostMixer = null;
      }
      placingInstitution = false;
      currentInstitution = null;
      placingApplication = false;
      applicationInfo = null;
      return;
    }


    // Raycast to detect institution click
    const mouse = new THREE.Vector2(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1
    );
    raycaster.setFromCamera(mouse, camera);
    const objs = Object.values(institutionsMap);
    const intersects = raycaster.intersectObjects(objs, true);
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && obj.userData && obj.userData.institutionId === undefined) {
        obj = obj.parent;
      }
      if (obj && obj.userData && obj.userData.institutionId !== undefined) {
        const id = obj.userData.institutionId;
        const data = institutionDataMap[id];
        if (data && !data.destroyed) {
          if (data.isPlanetHall) {
            showPlanetHallPopup();
          } else if (data.funded === false) {
            openBuySharesForm(data);
          } else {
            showInstitutionPopup(id);
          }
        }
        return;
      }
    }

    const wObjs = [];
    Object.values(weaponMap).forEach(arr => arr.forEach(w => { if (w && w.obj) wObjs.push(w.obj); }));
    const wHits = raycaster.intersectObjects(wObjs, true);
    if (wHits.length > 0) {
      let obj = wHits[0].object;
      while (obj && obj.userData && obj.userData.weaponInstId === undefined) {
        obj = obj.parent;
      }
      if (obj && obj.userData && obj.userData.weaponInstId !== undefined) {
        const iid = obj.userData.weaponInstId;
        const idx = obj.userData.weaponIndex;
        const w = weaponMap[iid] && weaponMap[iid][idx];
        if (w) alert('Using weapon ' + (w.data.name || '')); // placeholder
      }
    }
  }

  window.addEventListener('click', handleClick);

  let ghostSample = { x: null, z: null, y: 0 };
  function updateGhostInstitution() {
    if (!placingInstitution || !ghostInstitution || !model) return;
    const distance = ghostInstitution.userData.safeDistance || 20;
    const offset = new THREE.Vector3(0, 3, distance);
    offset.applyQuaternion(model.quaternion);
    const target = model.position.clone().add(offset);
    ghostInstitution.position.copy(target);
    ghostInstitution.rotation.y = model.rotation.y;
    const dx = ghostSample.x === null ? Infinity : Math.abs(target.x - ghostSample.x);
    const dz = ghostSample.z === null ? Infinity : Math.abs(target.z - ghostSample.z);
    if (dx > 0.25 || dz > 0.25) {
      ghostSample.x = target.x;
      ghostSample.z = target.z;
      const box = createBuildingFootprint(ghostInstitution);
      ghostSample.y = getMeanHeightInRect(box.minX, box.maxX, box.minZ, box.maxZ);
    }
    const box = new THREE.Box3().setFromObject(ghostInstitution);
    const offY = box.min.y - ghostInstitution.position.y;
    ghostInstitution.position.y = ghostSample.y - offY;
  }

  function getGroundHeightAt(x, z) {
    if (terrainMeshes.length === 0) return 0;
    const origin = new THREE.Vector3(x, 1000, z);
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const hits = raycaster.intersectObjects(getNearbyTerrain(origin), true);
    if (hits.length > 0) {
      return hits[0].point.y;
    }
    return 0;
  }

  function getMeanHeightInRect(minX, maxX, minZ, maxZ) {
    let sum = 0;
    let count = 0;
    const world = new THREE.Vector3();
    terrainMeshes.forEach(mesh => {
      const geom = mesh.geometry;
      if (!geom || !geom.attributes || !geom.attributes.position) return;
      const pos = geom.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        world.fromBufferAttribute(pos, i);
        world.applyMatrix4(mesh.matrixWorld);
        if (world.x >= minX && world.x <= maxX && world.z >= minZ && world.z <= maxZ) {
          sum += world.y;
          count++;
        }
      }
    });
    if (count === 0) return getGroundHeightAt((minX + maxX) / 2, (minZ + maxZ) / 2);
    return sum / count;
  }

  function flattenTerrain(minX, maxX, minZ, maxZ) {
    const height = getMeanHeightInRect(minX, maxX, minZ, maxZ);
    const target = new THREE.Vector3();
    const inv = new THREE.Matrix4();
    const world = new THREE.Vector3();
    terrainMeshes.forEach(mesh => {
      const geom = mesh.geometry;
      if (!geom || !geom.attributes || !geom.attributes.position) return;
      const pos = geom.attributes.position;
      inv.copy(mesh.matrixWorld).invert();
      for (let i = 0; i < pos.count; i++) {
        target.fromBufferAttribute(pos, i);
        world.copy(target).applyMatrix4(mesh.matrixWorld);
        if (world.x >= minX && world.x <= maxX && world.z >= minZ && world.z <= maxZ) {
          world.y = height;
          target.copy(world).applyMatrix4(inv);
          pos.setXYZ(i, target.x, target.y, target.z);
        }
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();
    });
    return height;
  }

  function updateStats() {
    if (dead) return;
    if (isMovingForward) {
      hydration = Math.max(hydration - 0.05, 0);
      oxygen = Math.max(oxygen - 0.02, 0);
    } else {
      hydration = Math.max(hydration - 0.02, 0);
      oxygen = Math.max(oxygen - 0.005, 0);
    }

    if (oxygen <= 10) lowOxygenOverlay.style.display = 'block';
    else lowOxygenOverlay.style.display = 'none';

    const canvas = renderer.domElement;
    if (hydration <= 20) {
      const maxBlur = 10;
      const blurAmount = maxBlur * (1 - hydration / 20);
      canvas.style.filter = `blur(${blurAmount.toFixed(1)}px)`;
    } else {
      canvas.style.filter = '';
    }

    if (oxygen <= 0 || hydration <= 0) {
      dead = true;
      deathOverlay.style.display = 'flex';
      if (dieAction) switchAnimation(dieAction);
    }

    updateStatImages();
  }

  function applyInstitutionEffects() {
    // First update tracking
    updateResourceTracking();

    ownedInstitutions.forEach(e => {
      if (!e || typeof e !== 'object') return;
      const f = e.factor == null ? 1 : e.factor;
      if (typeof e.hydration === 'number') hydration = Math.min(hydration + e.hydration * f, 1000);
      if (typeof e.oxygen === 'number') oxygen = Math.min(oxygen + e.oxygen * f, 1000);
      if (typeof e.health === 'number') health = Math.min(health + e.health * f, 1000);
      if (typeof e.money === 'number') {
        playerMoney += e.money * f;
        updateMoneyDisplay();
      }
    });

    // Workforce resource consumption
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => {
          if (!w.effects) return;
          if (w.effects.hydration) hydration = Math.max(hydration + w.effects.hydration, 0);
          if (w.effects.oxygen) oxygen = Math.max(oxygen + w.effects.oxygen, 0);
          if (w.effects.health) health = Math.max(health + w.effects.health, 0);
        });
      }
    });

    // Pay workforce wages
    let wages = 0;
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => { wages += w.wage || 0; });
      }
    });
    if (wages > 0) {
      playerMoney = Math.max(playerMoney - wages, 0);
      updateMoneyDisplay();
    }
    updateStatImages();
  }

  async function startVerification(email) {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    return res.ok;
  }

  async function verifyCode(email, code) {
    const res = await fetch('/api/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, code })
    });
    if (!res.ok) throw new Error('verify');
    const data = await res.json();
    startPosition = data.user.position;
    playerMoney = data.user.money || 0;
    health = data.user.health || 1000;
    hydration = data.user.hydration || 1000;
    oxygen = data.user.oxygen || 1000;
    updateStatImages();
    playerEmail = email;
    localStorage.setItem('playerEmail', email);
    const loaderEl = document.getElementById('loading-container');
    loaderEl.classList.remove('hidden');
    loaderEl.style.display = 'flex';
    document.getElementById('loading-bar').style.width = '0%';
    document.getElementById('login-container').style.display = 'none';
    const cached = await assetsInCache(PRELOAD_ASSETS);
    if (!cached) {
      document.getElementById('loading-text').textContent = 'Fetching files list...';
      startSlideshow();
      await preloadAssets(
        PRELOAD_ASSETS,
        p => {
          document.getElementById('loading-bar').style.width = `${Math.floor(p * 100)}%`;
        },
        msg => {
          document.getElementById('loading-text').textContent = msg;
        }
      );
      await playIntroSequence();
    } else {
      document.getElementById('loading-text').textContent = 'Using cached assets...';
      document.getElementById('loading-bar').style.width = '100%';
      loaderEl.classList.add('hidden');
      loaderEl.style.display = 'none';
    }
    initNetwork();
    updateMoneyDisplay();
    startGame();
  }

  document.getElementById('send-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    document.getElementById('login-error').textContent = '';
    if (await startVerification(email)) {
      const codeSec = document.getElementById('code-section');
      codeSec.classList.remove('hidden');
      codeSec.style.display = 'block';
      document.getElementById('login-code').focus();
    } else {
      document.getElementById('login-error').textContent = 'Failed to send code';
    }
  };

  document.getElementById('verify-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    const code = document.getElementById('login-code').value;
    try {
      await verifyCode(email, code);
    } catch (e) {
      document.getElementById('login-error').textContent = 'Verification failed';
    }
  };

  // Scene, camera, renderer
  const scene = new THREE.Scene();
  const marsSkyColor = 0x9B7653; // Dusty orange-red for Mars sky
  // Mild atmospheric haze
  scene.fog = new THREE.FogExp2(marsSkyColor, 0.002);

  // Adjusted camera far plane for potentially larger terrain
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 10, 15);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Better shadows
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(marsSkyColor);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  // Canvas is added after login

  // --- Audio setup ---
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const audioLoader = new THREE.AudioLoader();

  // Post-processing setup for bloom
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // Ambient occlusion pass for subtle shading
  const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
  ssaoPass.kernelRadius = 8;
  ssaoPass.minDistance = 0.005;
  ssaoPass.maxDistance = 0.1;
  composer.addPass(ssaoPass);

  // Bloom effect
  const bloomParams = {
    strength: 0.1,
    radius: 0.7,
    threshold: 0.8
  };
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    bloomParams.strength,
    bloomParams.radius,
    bloomParams.threshold
  );
  composer.addPass(bloomPass);

  // Output pass to properly handle tone mapping
  const outputPass = new OutputPass();
  composer.addPass(outputPass);

  // --- Multiplayer Networking ---
  let socket;
  let clientId = null;
  const remotePlayers = {};
  const pendingRemotePlayers = [];
  const institutionsMap = {};
  const institutionMixers = {};
  const institutionDataMap = {};
  // Lists of ground footprints for institutions and constructions
  const institutionBoxes = [];
  const constructionBoxes = [];
  const sinking = [];
  const constructionMap = {}; // id -> array of {scaff, final}
  const weaponMap = {}; // id -> array of weapon objects
  const projectiles = []; // active fired weapon objects
  const institutionSounds = {}; // id -> THREE.PositionalAudio
  const weaponSounds = {}; // instId -> array of sounds
  const weaponMixers = {}; // instId -> array of AnimationMixers
  let footstepSound = null;
  const flagObjects = {}; // player id -> flag object
  let currentFlagPos = null;
  const fundingIndicators = {};

  function initNetwork() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    socket = new WebSocket(`${protocol}//${window.location.host}/?email=${encodeURIComponent(playerEmail)}`);
    socket.addEventListener('message', e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'welcome') {
        clientId = msg.id;
        msg.players.forEach(p => {
          if (p.flag) createFlag(p.id, p.flag);
          if (p.id !== clientId) createRemotePlayer(p.id, p);
        });
        if (msg.institutions) {
          msg.institutions.forEach(i => createInstitution(i, false));
        }
        if (typeof msg.money === 'number') {
          playerMoney = msg.money;
          updateMoneyDisplay();
        }
        if (typeof msg.health === 'number') health = msg.health;
        if (typeof msg.hydration === 'number') hydration = msg.hydration;
        if (typeof msg.oxygen === 'number') oxygen = msg.oxygen;
        updateStatImages();
      } else if (msg.type === 'spawn') {
        if (msg.state && msg.state.flag) createFlag(msg.id, msg.state.flag);
        createRemotePlayer(msg.id, msg.state);
      } else if (msg.type === 'update') {
        if (msg.id !== clientId) updateRemotePlayer(msg.id, msg);
      } else if (msg.type === 'remove') {
        removeRemotePlayer(msg.id);
      } else if (msg.type === 'addInstitution') {
        createInstitution(msg.institution, true);
      } else if (msg.type === 'updateInstitution') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          inst.extraEffects = msg.extraEffects || inst.extraEffects || {};
          if (msg.construction !== undefined) {
            if (!Array.isArray(inst.constructions)) inst.constructions = [];
            inst.constructions[msg.index] = msg.construction;
            applyConstruction(inst);
          }
          if (
            inst.owner === playerEmail &&
            msg.gains &&
            typeof msg.gains === 'object' &&
            !Array.isArray(msg.gains)
          ) {
            addInstitutionEffects(msg.id, msg.gains);
          }
        }
      } else if (msg.type === 'updateInstitutionShares') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          inst.shares = msg.info.shares ? { ...inst.shares, [playerEmail]: msg.info.shares } : inst.shares;
          inst.soldShares = msg.info.soldShares;
          inst.totalShares = msg.info.totalShares;
          inst.sharePrice = msg.info.sharePrice;
          const wasFunded = inst.funded;
          inst.funded = msg.info.funded;
          if (!wasFunded && inst.funded) {
            removeFundingIndicator(inst.id);
            const obj = institutionsMap[inst.id];
            if (obj) obj.traverse(o=>{ if(o.isMesh && o.material && o.material.transparent){ o.material.opacity=1;o.material.transparent=false; }});
          }
        }
      } else if (msg.type === 'updateWeapon') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          if (!Array.isArray(inst.weapons)) inst.weapons = [];
          inst.weapons[msg.index] = msg.weapon;
          applyWeapons(inst);
        }
      } else if (msg.type === 'destroyInstitution') {
        handleInstitutionDestruction(msg.id);
      } else if (msg.type === 'money') {
        playerMoney = msg.money;
        updateMoneyDisplay();
      } else if (msg.type === 'flag') {
        createFlag(msg.id, msg.position);
      } else if (msg.type === 'hallChat') {
        loadHallChat();
      } else if (msg.type === 'newPolicy' || msg.type === 'policyVote') {
        loadPolicies();
      } else if (
        msg.type === 'referendumStart' ||
        msg.type === 'referendumProgress' ||
        msg.type === 'referendumResult'
      ) {
        loadReferendum();
      } else if (msg.type === 'respawn') {
  dead = false;
  deathOverlay.style.display = 'none';

  // Set values
  oxygen = msg.oxygen;
  hydration = msg.hydration;
  health = msg.health;
  playerMoney = msg.money;

  // Clear effects
  renderer.domElement.style.filter = '';
  lowOxygenOverlay.style.display = 'none';

  // FORCE RESET IMAGES - DIRECT APPROACH
  healthImg.dataset.current = '';  // Clear cache
  hydrationImg.dataset.current = '';
  oxygenImg.dataset.current = '';

  // DIRECTLY SET TO FULL IMAGES
  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  updateMoneyDisplay();
  if (idleAction) switchAnimation(idleAction);
}
    });
  }

  function createRemotePlayer(id, state) {
    if (!model) {
      pendingRemotePlayers.push({ id, state });
      return;
    }
    if (remotePlayers[id]) return;
    const remote = SkeletonUtils.clone(model);
    scene.add(remote);
    const m = new THREE.AnimationMixer(remote);
    let idle, walk, run, die;
    if (playerAnimations) {
      const idleClip = playerAnimations.find(a => a.name.toLowerCase() === 'idle');
      const walkClip = playerAnimations.find(a => a.name.toLowerCase() === 'walk');
      const runClip = playerAnimations.find(a => a.name.toLowerCase() === 'run');
      const dieClip = playerAnimations.find(a => a.name.toLowerCase() === 'die');
      if (idleClip) idle = m.clipAction(idleClip);
      if (walkClip) walk = m.clipAction(walkClip);
      if (runClip) run = m.clipAction(runClip);
      if (dieClip) {
        die = m.clipAction(dieClip);
        die.setLoop(THREE.LoopOnce, 1);
        die.clampWhenFinished = true;
      }
    }
    if (idle) idle.play();
    remotePlayers[id] = { model: remote, mixer: m, idle, walk, run, die, active: idle };
    if (state) {
      remote.position.fromArray(state.position);
      remote.rotation.y = state.rotation;
    }
  }

  function updateRemotePlayer(id, state) {
    const rp = remotePlayers[id];
    if (!rp) return;
    rp.model.position.fromArray(state.position);
    rp.model.rotation.y = state.rotation;
    let target = rp.idle;
    if (state.oxygen <= 0 || state.hydration <= 0) {
      target = rp.die || target;
    } else if (typeof state.moving === 'boolean') {
      if (state.moving) {
        target = state.running ? rp.run : (rp.walk || rp.run);
      } else {
        target = rp.idle;
      }
    }
    if (target && rp.active !== target) {
      rp.active && rp.active.fadeOut(0.2);
      target.reset().fadeIn(0.2).play();
      rp.active = target;
    }
  }

  function removeRemotePlayer(id) {
    const rp = remotePlayers[id];
    if (!rp) return;
    scene.remove(rp.model);
    delete remotePlayers[id];
  }

  function removeConstructionBoxes(id) {
    for (let i = constructionBoxes.length - 1; i >= 0; i--) {
      if (constructionBoxes[i].id === id) constructionBoxes.splice(i, 1);
    }
  }

  function applyConstruction(inst) {
    const existing = constructionMap[inst.id] || [];
    existing.forEach(e => {
      if (e.scaff) scene.remove(e.scaff);
      if (e.final) scene.remove(e.final);
    });
    removeConstructionBoxes(inst.id);
    constructionMap[inst.id] = [];
    if (!Array.isArray(inst.constructions)) return;
    inst.constructions.forEach((c, idx) => {
      if (!c) return;
      const loader = new GLTFLoader();
      loader.load(c.url, gltf => {
        if (inst.constructions[idx] !== c) return; // ignore outdated load
        const obj = gltf.scene || (gltf.scenes && gltf.scenes[0]);
        if (!obj) return;
        addPointLightsFromGLTF(gltf);
        const offset = Array.isArray(c.offset)
          ? new THREE.Vector3().fromArray(c.offset)
          : null;
        let pos = new THREE.Vector3().fromArray(inst.position);
        if (offset) {
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
          pos.add(offset);
        } else {
          const boxEntry = institutionBoxes.find(b => b.id === inst.id);
          if (boxEntry) {
            const width = boxEntry.box.maxX - boxEntry.box.minX;
            const off = new THREE.Vector3(width / 2 + 5, 0, 0);
            off.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
            pos.add(off);
          } else {
            pos.x += 5;
          }
        }

        obj.scale.setScalar(c.scale || inst.scale || 1);
        obj.rotation.y = inst.rotation || 0;
        obj.position.copy(pos);
        scene.add(obj);
        const boxTmp = new THREE.Box3().setFromObject(obj);
        const fp = createBuildingFootprint(obj);
        const ground = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
        const offY = boxTmp.min.y - obj.position.y;
        obj.position.y = ground - offY;

        const cbox = createBuildingFootprint(obj);
        constructionBoxes.push({ id: inst.id, index: idx, box: cbox });

        if (!constructionMap[inst.id][idx]) constructionMap[inst.id][idx] = {};
        if (c.status === 'scaffolding') {
          constructionMap[inst.id][idx].scaff = obj;
        } else {
          constructionMap[inst.id][idx].final = obj;
        }
      }, undefined, () => {
        if (inst.constructions[idx] !== c) return;
        const obj = createPlaceholder(c.scale || inst.scale || 1, 0x888888);
        const offset = Array.isArray(c.offset)
          ? new THREE.Vector3().fromArray(c.offset)
          : null;
        let pos = new THREE.Vector3().fromArray(inst.position);
        if (offset) {
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
          pos.add(offset);
        } else {
          const boxEntry = institutionBoxes.find(b => b.id === inst.id);
          if (boxEntry) {
            const width = boxEntry.box.maxX - boxEntry.box.minX;
            const off = new THREE.Vector3(width / 2 + 5, 0, 0);
            off.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
            pos.add(off);
          } else {
            pos.x += 5;
          }
        }
        obj.position.copy(pos);
        scene.add(obj);
        const boxTmp2 = new THREE.Box3().setFromObject(obj);
        const fp2 = createBuildingFootprint(obj);
        const ground2 = flattenTerrain(fp2.minX, fp2.maxX, fp2.minZ, fp2.maxZ);
        const offY2 = boxTmp2.min.y - obj.position.y;
        obj.position.y = ground2 - offY2;
        const cbox = createBuildingFootprint(obj);
        constructionBoxes.push({ id: inst.id, index: idx, box: cbox });
        if (!constructionMap[inst.id][idx]) constructionMap[inst.id][idx] = {};
        if (c.status === 'scaffolding') {
          constructionMap[inst.id][idx].scaff = obj;
        } else {
          constructionMap[inst.id][idx].final = obj;
        }
      });
    });
  }

  function createFlag(id, position) {
    if (!position || position.length < 3) return;
    const pos = Array.isArray(position) ? new THREE.Vector3().fromArray(position) : position.clone();
    let existing = flagObjects[id];
    if (existing) scene.remove(existing);
    const loader = new GLTFLoader();
    loader.load('flag.glb', gltf => {
      const obj = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!obj) return;
      obj.position.copy(pos);
      scene.add(obj);
      flagObjects[id] = obj;
      if (id === clientId) currentFlagPos = obj.position;
    }, undefined, () => {
      const obj = createPlaceholder(0.5, 0xff0000);
      obj.position.copy(pos);
      scene.add(obj);
      flagObjects[id] = obj;
      if (id === clientId) currentFlagPos = obj.position;
    });
  }

  function createFundingIndicator(id, position) {
    const pos = new THREE.Vector3().fromArray(position);
    pos.y += 30;
    const geom = new THREE.SphereGeometry(4, 16, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const sph = new THREE.Mesh(geom, mat);
    sph.position.copy(pos);
    scene.add(sph);
    fundingIndicators[id] = sph;
  }

  function removeFundingIndicator(id) {
    const obj = fundingIndicators[id];
    if (obj) { scene.remove(obj); delete fundingIndicators[id]; }
  }

  function plantFlag() {
    if (!model) return;
    // Place the flag a few units in front of the player instead of behind
    const offset = new THREE.Vector3(0, 0, 3).applyQuaternion(model.quaternion);
    const pos = model.position.clone().add(offset);
    const y = getGroundHeightAt(pos.x, pos.z);
    pos.y = y;
    createFlag(clientId, [pos.x, pos.y, pos.z]);
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'target', position: [pos.x, pos.y, pos.z] }));
    }
    if (flagPlantAction) switchAnimation(flagPlantAction);
  }

  function applyWeapons(inst) {
    const existing = weaponMap[inst.id] || [];
    existing.forEach(w => { if (w.obj) scene.remove(w.obj); });
    const mixArr = weaponMixers[inst.id] || [];
    mixArr.forEach(m => { if (m) { m.stopAllAction(); } });
    weaponMixers[inst.id] = [];
    weaponMap[inst.id] = [];
    if (!Array.isArray(inst.weapons)) return;
    inst.weapons.forEach((w, idx) => {
      if (!w) return;
      const offset = Array.isArray(w.offset)
        ? new THREE.Vector3().fromArray(w.offset)
        : new THREE.Vector3(6 + idx * 2, 0, 0);
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
      const pos = new THREE.Vector3().fromArray(inst.position).add(offset);

      if (!w.model) {
        const obj = createPlaceholder(w.scale || 1, 0xff0000);
        obj.position.copy(pos);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        const boxTmp = new THREE.Box3().setFromObject(obj);
        const fp = createBuildingFootprint(obj);
        const ground = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
        const offY = boxTmp.min.y - obj.position.y;
        obj.position.y = ground - offY;
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };
        return;
      }

      const loader = new GLTFLoader();
      loader.load(w.model, gltf => {
        if (inst.weapons[idx] !== w) return; // ignore outdated load
        const obj = gltf.scene || (gltf.scenes && gltf.scenes[0]);
        if (!obj) return;
        addPointLightsFromGLTF(gltf);
      obj.scale.setScalar(w.scale || 1);
      obj.rotation.y = inst.rotation || 0;
      obj.position.copy(pos);
      scene.add(obj);
      if (gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        gltf.animations.forEach(anim => mix.clipAction(anim).play());
        if (!weaponMixers[inst.id]) weaponMixers[inst.id] = [];
        weaponMixers[inst.id][idx] = mix;
      }

      let techKey = w.technology;
      if (Array.isArray(techKey)) techKey = techKey[0];
      if (techKey && typeof techKey === 'object') {
        const keys = Object.keys(techKey);
        techKey = keys.length ? keys[0] : '';
      }
      const techFile = weaponAudioFiles[(typeof techKey === 'string' ? techKey : '').toLowerCase()];
      if (techFile) {
        const wsound = new THREE.PositionalAudio(listener);
        audioLoader.load(techFile, buffer => {
          wsound.setBuffer(buffer);
          wsound.setLoop(true);
          wsound.setRefDistance(15);
          wsound.setVolume(1);
          wsound.play();
        });
        obj.add(wsound);
        if (!weaponSounds[inst.id]) weaponSounds[inst.id] = [];
        weaponSounds[inst.id][idx] = wsound;
      }

      const boxTmp = new THREE.Box3().setFromObject(obj);
        const fp = createBuildingFootprint(obj);
        const ground = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
        const offY = boxTmp.min.y - obj.position.y;
        obj.position.y = ground - offY;
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };

        // Debug: log weapon placement when the generated model is loaded
        if (DEBUG_LOG) {
          console.log('[DEBUG] Weapon model loaded', {
            institution: inst.id,
            index: idx,
            position: {
              x: obj.position.x,
              y: obj.position.y,
              z: obj.position.z
            }
          });
        }
      }, undefined, () => {
        if (inst.weapons[idx] !== w) return;
        const obj = createPlaceholder(w.scale || 1, 0xff0000);
        obj.position.copy(pos);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        const boxTmp2 = new THREE.Box3().setFromObject(obj);
        const fp2 = createBuildingFootprint(obj);
        const ground2 = flattenTerrain(fp2.minX, fp2.maxX, fp2.minZ, fp2.maxZ);
        const offY2 = boxTmp2.min.y - obj.position.y;
        obj.position.y = ground2 - offY2;
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };
      });
    });
  }

  function fireWeapon(entry) {
    if (!model || !entry || !entry.obj || !entry.data) return;
    const params = entry.data.parameters || {};
    let tech = entry.data.technology;
    if (Array.isArray(tech)) tech = tech[0];
    if (tech && typeof tech === 'object') {
      const keys = Object.keys(tech);
      tech = keys.length ? keys[0] : '';
    }
    tech = (typeof tech === 'string' ? tech : '').toLowerCase();
    const cat = (entry.data.category || '').toLowerCase();
    const start = entry.obj.position.clone();
    const target = currentFlagPos ? currentFlagPos.clone() : model.position.clone();
    const clone = SkeletonUtils.clone(entry.obj);
    clone.position.copy(start);
    scene.add(clone);
    projectiles.push({ obj: clone, tech, cat, params, start, target, stage: 0, speed: 0 });

    // Debug: log weapon firing start information
    if (DEBUG_LOG) {
      console.log('[DEBUG] Fire weapon', {
        weaponTech: tech,
        weaponCategory: cat,
        params,
        characterPosition: {
          x: target.x,
          y: target.y,
          z: target.z
        },
        startPosition: {
          x: start.x,
          y: start.y,
          z: start.z
        },
        animation: activeAction && activeAction._clip ? activeAction._clip.name : 'none'
      });
    }
  }

  function fireAllWeapons() {
    Object.values(weaponMap).forEach(arr => arr.forEach(w => fireWeapon(w)));
  }

  function updateProjectiles(dt) {
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      const weight = p.params.weight || 1;
      const force = p.params.force || 0;
      const ammo = p.params.ammo || 0;
      const fuel = p.params.fuel || 0;
      if (p.cat !== 'attack') {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
        continue;
      }
      // check collision with institutions
      const sphere = new THREE.Sphere(p.obj.position.clone(), 20);
      let hitInst = null;
      for (const entry of institutionBoxes) {
        const data = institutionDataMap[entry.id];
        if (!data || data.destroyed) continue;
        if (sphereIntersectsFootprint(entry.box, sphere)) {
          hitInst = entry.id;
          break;
        }
      }
      if (hitInst !== null) {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
        sendDestroyInstitution(hitInst);
        continue;
      }
      if (p.tech === 'laser') {
        if (!p.dir) {
          p.dir = new THREE.Vector3().subVectors(p.target, p.start).normalize();
          p.speed = force * 1;
        }
        const step = p.speed * dt;
        p.obj.position.addScaledVector(p.dir, step);
        if (p.obj.position.distanceTo(p.target) <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else if (p.tech === 'bullet') {
        if (!p.dir) {
          p.dir = new THREE.Vector3().subVectors(p.target, p.start).normalize();
          p.speed = weight > 0 ? (force / weight) : force;
        }
        const step = p.speed * dt;
        p.obj.position.addScaledVector(p.dir, step);
        if (p.obj.position.distanceTo(p.target) <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else if (p.tech === 'missile') {
        if (p.stage === 0) {
          p.h = p.h || (force * fuel / (weight + ammo + fuel)) * 10;
          p.v0 = p.v0 || (force / weight);
          p.v1 = p.v1 || (weight * p.h);
          p.speed = p.v0;
          const targetY = p.start.y + p.h;
          p.obj.position.y += p.v0 * dt;
          if (p.obj.position.y >= targetY) {
            p.stage = 1;
            p.dir = new THREE.Vector3().subVectors(p.target, p.obj.position).normalize();
          }
        } else {
          p.speed += (p.v1 - p.speed) * 0.05;
          const step = p.speed * dt;
          p.obj.position.addScaledVector(p.dir, step);
          if (p.obj.position.distanceTo(p.target) <= step) {
            scene.remove(p.obj);
            projectiles.splice(i, 1);
          }
        }
      } else if (p.tech === 'drone') {
        p.h = p.h || (force / weight) * 10;
        p.v0 = p.v0 || (force / weight);
        p.v1 = p.v1 || (weight * p.h);
        if (p.stage === 0) {
          const targetY = p.start.y + p.h;
          p.obj.position.y += p.v0 * dt;
          if (p.obj.position.y >= targetY) {
            p.stage = 1;
          }
        } else if (p.stage === 1) {
          if (!p.dir) p.dir = new THREE.Vector3(p.target.x - p.obj.position.x, 0, p.target.z - p.obj.position.z).normalize();
          p.speed += (p.v1 - (p.speed || p.v0)) * 0.05;
          const step = p.speed * dt;
          const move = p.dir.clone().multiplyScalar(step);
          p.obj.position.add(move);
          if (new THREE.Vector2(p.obj.position.x - p.target.x, p.obj.position.z - p.target.z).length() <= step) {
            p.stage = 2;
            p.dir = new THREE.Vector3(0, -1, 0);
          }
        } else {
          const step = p.v1 * dt;
          p.obj.position.addScaledVector(p.dir, step);
          if (p.obj.position.y <= p.target.y) {
            p.obj.position.copy(p.target);
            scene.remove(p.obj);
            projectiles.splice(i, 1);
          }
        }
      } else if (p.tech === 'kamikaze') {
        if (!p.dir) p.dir = new THREE.Vector2(p.target.x - p.start.x, p.target.z - p.start.z).normalize();
        p.speed = p.speed || ((force * fuel) / weight);
        const step = p.speed * dt;
        p.obj.position.x += p.dir.x * step;
        p.obj.position.z += p.dir.y * step;
        p.obj.position.y = getGroundHeightAt(p.obj.position.x, p.obj.position.z);
        if (new THREE.Vector2(p.obj.position.x - p.target.x, p.obj.position.z - p.target.z).length() <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
      }
    }
  }

  function handleInstitutionDestruction(id) {
    const obj = institutionsMap[id];
    const data = institutionDataMap[id];
    if (!obj || !data || data.destroyed) return;
    data.destroyed = true;
    data.workforce = [];
    data.proposals = [];
    data.proposalHistory = [];
    data.constructions = [];
    removeInstitutionEffects(id);
    const anims = obj.userData.animations || [];
    if (anims.length > 0) {
      const clip = anims.find(a => a.name === 'destruction') || anims[0];
      const mix = new THREE.AnimationMixer(obj);
      const action = mix.clipAction(clip);
      action.setLoop(THREE.LoopOnce, 0);
      action.clampWhenFinished = true;
      action.play();
      action.onFinished = () => {
        action.paused = true;
        action.time = clip.duration;
        mix.update(0);
      };
      institutionMixers[id] = mix;
    }
  }

  async function createInstitution(inst, animate) {
    const def = institutions.find(i => i.name === inst.name);
    if (!def) return;
    try {
      const gltf = await loadGLTFCached(def.url);
      const obj = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!obj) return;
      obj.userData.animations = gltf.animations || [];
      addPointLightsFromGLTF(gltf);
      obj.scale.setScalar(inst.scale || def.scale || 1);
      obj.position.fromArray(inst.position);
      obj.rotation.y = inst.rotation || 0;
      obj.traverse(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
          if (inst.funded === false) {
            o.material = o.material.clone();
            o.material.transparent = true;
            o.material.opacity = 0.5;
          }
        }
      });
      const boxTmp = new THREE.Box3().setFromObject(obj);
      const fp = createBuildingFootprint(obj);
      const ground = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
      const offY = boxTmp.min.y - obj.position.y;
      obj.position.y = ground - offY;
      scene.add(obj);

      const instAudioFile = institutionAudioFiles[inst.name];
      if (instAudioFile) {
        const sound = new THREE.PositionalAudio(listener);
       audioLoader.load(instAudioFile, buffer => {
      sound.setLoop(true);
      sound.setRefDistance(1);
      sound.setRolloffFactor(10.0);
      sound.setMaxDistance(10);
      sound.setVolume(1);
      sound.setBuffer(buffer);
      if (sound.isPlaying) sound.stop();
      sound.play();
    });

        obj.add(sound);
        institutionSounds[inst.id] = sound;
      }

      if (inst.destroyed && gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        const clip = gltf.animations.find(a => a.name === 'destruction') || gltf.animations[0];
        const action = mix.clipAction(clip);
        action.play();
        action.paused = true;
        action.time = clip.duration;
        mix.update(0);
      } else if (def.animated && gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        gltf.animations.forEach(anim => {
          mix.clipAction(anim).play();
        });
        institutionMixers[inst.id] = mix;
      }
      institutionsMap[inst.id] = obj;
      const cons = inst.constructions || (inst.construction ? [inst.construction] : []);
      institutionDataMap[inst.id] = { ...inst, effects: def.effects, workforce: inst.workforce || [], extraEffects: inst.extraEffects || {}, constructions: cons };
      obj.traverse(o => { o.userData.institutionId = inst.id; });
      const box = createBuildingFootprint(obj);
      institutionBoxes.push({ id: inst.id, box });
      if (!inst.destroyed) {
        applyConstruction(institutionDataMap[inst.id]);
        applyWeapons(institutionDataMap[inst.id]);
      }
      if (inst.funded === false) {
        createFundingIndicator(inst.id, inst.position);
      }
      if (inst.owner === playerEmail && !inst.destroyed) {
        if (def.effects) addInstitutionEffects(inst.id, def.effects);
        if (inst.extraEffects) addInstitutionEffects(inst.id, inst.extraEffects);
      }
      if (animate) {
        const startY = obj.position.y + 5;
        const endY = obj.position.y;
        obj.position.y = startY;
        sinking.push({ obj, start: startY, end: endY, t: 0, emit: 0 });
      }
    } catch (e) {
      console.error('Failed to load institution', def.url, e);
      const obj = createPlaceholder(inst.scale || def.scale || 1, 0x00aa00);
      obj.userData.animations = [];
      obj.position.fromArray(inst.position);
      obj.rotation.y = inst.rotation || 0;
      scene.add(obj);
      const boxTmp = new THREE.Box3().setFromObject(obj);
      const fp = createBuildingFootprint(obj);
      const ground = flattenTerrain(fp.minX, fp.maxX, fp.minZ, fp.maxZ);
      const offY = boxTmp.min.y - obj.position.y;
      obj.position.y = ground - offY;
      obj.traverse(o => { o.userData.institutionId = inst.id; });
      institutionsMap[inst.id] = obj;
      const box = createBuildingFootprint(obj);
      institutionBoxes.push({ id: inst.id, box });
      institutionDataMap[inst.id] = { ...inst, effects: def.effects, workforce: inst.workforce || [], extraEffects: inst.extraEffects || {}, constructions: inst.constructions || [] };
      if (!inst.destroyed) {
        applyConstruction(institutionDataMap[inst.id]);
        applyWeapons(institutionDataMap[inst.id]);
      }
    }
  }

// In index.html, replace the showInstitutionPopup function with this updated version:

function showInstitutionPopup(id) {
  const popup = document.getElementById('institution-popup');
  const infoTabBtn = document.getElementById('info-tab-btn');
  const workforceTabBtn = document.getElementById('workforce-tab-btn');
  const chatTabBtn = document.getElementById('chat-tab-btn');
  const proposalsTabBtn = document.getElementById('proposals-tab-btn');
  const weaponsTabBtn = document.getElementById('weapons-tab-btn');
  const infoDiv = document.getElementById('popup-info');
  const workforceDiv = document.getElementById('popup-workforce');
  const chatDiv = document.getElementById('popup-chat');
  const proposalsDiv = document.getElementById('popup-proposals');
  const weaponsDiv = document.getElementById('popup-weapons');
  const chatContainer = document.getElementById('chat-container');
  const ownerSpan = document.getElementById('popup-owner');
  const resDiv = document.getElementById('popup-resources');
  const closeBtn = document.getElementById('popup-close');

  let chatInterval = null;

  const instData = institutionDataMap[id];
  if (!instData || instData.destroyed) return;

  // Check if user is owner OR has shares (is a partner)
  const isOwner = instData.owner === playerEmail;
  const userShares = instData.shares && instData.shares[playerEmail] ? instData.shares[playerEmail] : 0;
  const hasAccess = isOwner || userShares > 0;

  const def = institutions.find(i => i.name === instData.name);
  let count = 0;
  Object.values(institutionDataMap).forEach(d => {
    if (d.owner === instData.owner && d.name === instData.name) count++;
  });
  const effects = Object.assign({}, def.effects || {});
  if (instData.extraEffects) {
    for (const k of Object.keys(instData.extraEffects)) {
      const val = instData.extraEffects[k];
      if (typeof val === 'number' && isFinite(val)) {
        effects[k] = (effects[k] || 0) + val;
      }
    }
  }
  const lines = [];
  Object.keys(effects).forEach(k => {
    if (typeof effects[k] === 'number' && isFinite(effects[k])) {
      lines.push(`${k}: +${effects[k]} (${(effects[k] * count).toFixed(2)} total)`);
    }
  });
  resDiv.textContent = lines.join(' | ');

  const actionsDiv = popup.querySelector('.popup-actions');

  // Show controls if user has access (owner or partner)
  if (hasAccess) {
    actionsDiv.style.display = 'flex';
    resDiv.style.display = 'block';

    // Show ownership info with shares
    let ownerText = `Owner: ${instData.owner}`;
    if (userShares > 0) {
      ownerText += ` | Your shares: ${userShares}/${instData.totalShares}`;
    }
    ownerSpan.innerHTML = isOwner
      ? `<span id="owner-click" style="text-decoration:underline;cursor:pointer;">${ownerText}</span>`
      : ownerText;
  } else {
    actionsDiv.style.display = 'none';
    resDiv.style.display = 'none';
    ownerSpan.textContent = `Owner: ${instData.owner}`;
  }

  function showInfo() {
    infoDiv.classList.remove('hidden');
    workforceDiv.classList.add('hidden');
    chatDiv.classList.add('hidden');
    proposalsDiv.classList.add('hidden');
    weaponsDiv.classList.add('hidden');
    if (chatInterval) {
      clearInterval(chatInterval);
      chatInterval = null;
    }
    const carousel = document.getElementById('popup-workforce-carousel');
    carousel.innerHTML = '';
    const workers = Array.isArray(instData.workforce) ? instData.workforce : [];
    if (workers.length === 0) {
      carousel.textContent = 'No workforce';
      return;
    }
    workers.forEach((w, idx) => {
      const item = document.createElement('div');
      item.style.minWidth = '80px';
      item.style.display = 'flex';
      item.style.flexDirection = 'column';
      item.style.alignItems = 'center';
      item.style.cursor = 'pointer';

      const img = document.createElement('img');
      img.src = w.image;
      img.style.width = '60px';
      img.style.height = '80px';
      item.appendChild(img);

      const name = document.createElement('div');
      name.textContent = w.name + (w.director ? ' \u2605' : '');
      name.style.fontSize = '12px';
      item.appendChild(name);

      item.onclick = () => {
        showWorkerProfile(w, id, true, idx);
      };

      carousel.appendChild(item);
    });
  }

async function showWorkforce() {
    infoDiv.classList.add('hidden');
    workforceDiv.classList.remove('hidden');
    workforceDiv.style.display = 'block';  // Explicitly set display to override CSS
    chatDiv.classList.add('hidden');
    proposalsDiv.classList.add('hidden');
    weaponsDiv.classList.add('hidden');
    if (chatInterval) {
      clearInterval(chatInterval);
      chatInterval = null;
    }
    const container = document.getElementById('workforce-container');
    // Immediately show loading spinner
    container.innerHTML = '<div class="spinner" style="display: flex; justify-content: center; align-items: center; height: 200px; color: #fff;">Loading applicants...</div>';

    try {
      console.log('Requesting applicants from', `/api/workforce/generate/${id}`);
      const res = await fetch(`/api/workforce/generate/${id}`, { method: 'POST' });
      console.log('Generate response status', res.status);
      if (!res.ok) {
        throw new Error(`HTTP error! status: ${res.status}`);
      }
      const rawText = await res.clone().text();
      console.log('Raw generate response', rawText);
      const workersData = await res.json();

      // Clear loading and display workers
      container.innerHTML = '';

      if (!workersData.workers || workersData.workers.length === 0) {
        container.innerHTML = '<div style="color: #fff; text-align: center;">No applicants available</div>';
        return;
      }

      workersData.workers.forEach(w => {
        const card = document.createElement('div');
        card.className = 'worker-card';
        card.style.width = '150px';
        card.style.perspective = '800px';
        const inner = document.createElement('div');
        inner.className = 'card-inner';
        inner.style.position = 'relative';
        inner.style.width = '100%';
        inner.style.height = '200px';
        inner.style.transition = 'transform 0.6s';
        inner.style.transformStyle = 'preserve-3d';
        const front = document.createElement('div');
        front.style.position = 'absolute';
        front.style.backfaceVisibility = 'hidden';
        front.style.width = '100%';
        front.style.height = '100%';
        front.style.backgroundImage = `url(${w.image})`;
        front.style.backgroundSize = 'cover';
        front.style.backgroundPosition = 'center';
        front.textContent = w.name + (w.director ? ' \u2605' : '');
        front.style.display = 'flex';
        front.style.alignItems = 'flex-end';
        front.style.justifyContent = 'center';
        front.style.color = '#fff';
        front.style.textShadow = '0 1px 3px rgba(0,0,0,0.8)';
        front.style.padding = '8px';
        front.style.textAlign = 'center';
        front.style.fontSize = '14px';
        front.style.fontWeight = 'bold';
        const back = document.createElement('div');
        back.style.position = 'absolute';
        back.style.transform = 'rotateY(180deg)';
        back.style.backfaceVisibility = 'hidden';
        back.style.width = '100%';
        back.style.height = '100%';
        back.style.background = '#333';
        back.style.color = '#fff';
        back.style.fontSize = '12px';
        back.style.padding = '8px';
        back.style.overflowY = 'auto';
        back.style.boxSizing = 'border-box';
        back.innerHTML = `
          <div style="margin-bottom: 8px;"><strong>${w.role}${w.director ? ' \u2605' : ''}</strong></div>
          <div style="margin-bottom: 8px; font-size: 11px;">${w.backstory}</div>
          <div style="margin-bottom: 8px; font-size: 11px;">${w.resume}</div>
          <div style="font-weight: bold;">Wage: $${w.wage}/day</div>
        `;
        inner.appendChild(front);
        inner.appendChild(back);
        card.appendChild(inner);
        card.onclick = () => {
          showWorkerProfile(w, id, false);
        };
        const hireBtn = document.createElement('button');
        hireBtn.textContent = 'Hire';
        hireBtn.style.width = '100%';
        hireBtn.style.marginTop = '20px';
        hireBtn.onclick = async (e) => {
          e.stopPropagation();
          try {
            const hireRes = await fetch(`/api/workforce/hire/${id}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ worker: w })
            });
            if (hireRes.ok) {
              if (!instData.workforce) instData.workforce = [];
              instData.workforce.push(w);
              container.removeChild(card);
              if (container.children.length === 0) {
                container.innerHTML = '<div style="color: #fff; text-align: center;">All applicants hired!</div>';
              }
            } else {
              alert('Failed to hire worker');
            }
          } catch (err) {
            alert('Failed to hire worker');
          }
        };
        card.appendChild(hireBtn);
        container.appendChild(card);
      });
    } catch (err) {
      console.error('Failed to load applicants', err);
      container.innerHTML = '<div style="color: #ff6666; text-align: center;">Failed to load applicants. Please try again.</div>';
    }
  }

  async function showChat() {
    infoDiv.classList.add('hidden');
    workforceDiv.classList.add('hidden');
    chatDiv.classList.remove('hidden');
    proposalsDiv.classList.add('hidden');
    weaponsDiv.classList.add('hidden');
    if (chatInterval) clearInterval(chatInterval);
    const input = document.getElementById('chat-input');
    const sendBtn = document.getElementById('chat-send');
    let lastHeight = 0;
    async function load() {
      try {
        const res = await fetch(`/api/workforce/chat/${id}`);
        if (res.ok) {
          const data = await res.json();
          chatContainer.innerHTML = '';
          data.messages.forEach(m => {
            const box = document.createElement('div');
            box.className = 'chat-msg';
            let text = m.text;
            if (typeof m.text === 'object' && m.text !== null) {
              text = m.text.dialogue || '';
              if (m.text.is_proposal && m.text.proposal) {
                const p = m.text.proposal;
                const parts = [];
                if (p.title) parts.push(`Title: ${p.title}`);
                if (p.description) parts.push(`Description: ${p.description}`);
                if (p.cost !== undefined) parts.push(`Cost: $${p.cost}`);
                const info = parts.join(' | ');
                if (info) text += ` (Proposal - ${info})`;
              }
            }
            box.textContent = `${m.worker}: ${text}`;
            chatContainer.appendChild(box);
            if (typeof m.text === 'object' && m.text !== null && m.text.raw) {
              const preRaw = document.createElement('pre');
              preRaw.className = 'chat-raw';
              preRaw.textContent = m.text.raw;
              chatContainer.appendChild(preRaw);
              if (m.text.proposal) {
                const preObj = document.createElement('pre');
                preObj.className = 'chat-raw';
                preObj.textContent = JSON.stringify(m.text.proposal, null, 2);
                chatContainer.appendChild(preObj);
              }
            }
          });
          if (chatContainer.scrollHeight !== lastHeight) {
            chatContainer.scrollTop = chatContainer.scrollHeight;
            lastHeight = chatContainer.scrollHeight;
          }
        }
      } catch (err) {
      }
    }
    await load();
    chatInterval = setInterval(load, 5000);

    async function send() {
      const text = input.value.trim();
      if (!text) return;
      input.value = '';
      await fetch(`/api/workforce/chat/${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      await load();
    }

    sendBtn.onclick = send;
    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') send();
    });
  }

  async function showProposals() {
    infoDiv.classList.add('hidden');
    workforceDiv.classList.add('hidden');
    chatDiv.classList.add('hidden');
    proposalsDiv.classList.remove('hidden');
    weaponsDiv.classList.add('hidden');
    if (chatInterval) { clearInterval(chatInterval); chatInterval = null; }
    const container = document.getElementById('proposals-container');
    container.innerHTML = '<div class="spinner" style="height:100px;color:#fff">Loading...</div>';
    if (DEBUG_LOG) console.log('[DEFENCE UI] showProposals', { instId: id });
    try {
      if (instData.name === 'Defence Base') {
        const res = await fetch(`/api/defence/proposals/${id}`);
        if (res.ok) {
          const data = await res.json();
          renderDefProposals(
            container,
            data.proposals || [],
            id,
            institutionDataMap,
            playerEmail
          );
        }
      } else {
        const res = await fetch(`/api/workforce/proposals/${id}`);
        const hist = await fetch(`/api/workforce/proposals/history/${id}`);
        if (res.ok && hist.ok) {
          const data = await res.json();
          const h = await hist.json();
          renderProposals(container, data.proposals || [], id, institutionDataMap, playerEmail, ownedInstitutions, h.history || []);
        }
      }
    } catch(err){
      container.innerHTML = '<div style="color:#ff6666">Failed</div>';
    }
  }

  async function showWeapons() {
    infoDiv.classList.add('hidden');
    workforceDiv.classList.add('hidden');
    chatDiv.classList.add('hidden');
    proposalsDiv.classList.add('hidden');
    weaponsDiv.classList.remove('hidden');
    if (chatInterval) { clearInterval(chatInterval); chatInterval = null; }
    const container = document.getElementById('weapons-container');
    container.innerHTML = '<div class="spinner" style="height:100px;color:#fff">Loading...</div>';
    try {
      const res = await fetch(`/api/defence/weapons/${id}`);
      if (res.ok) {
        const data = await res.json();
        container.innerHTML = '';
        (data.weapons || []).forEach(w => {
          const div = document.createElement('div');
          div.textContent = `${w.name} - movement ${w.movement.toFixed(2)}`;
          div.className = 'weapon-entry';
          div.onclick = () => alert('Using weapon ' + w.name);
          container.appendChild(div);
        });
        if (!data.weapons || data.weapons.length === 0) {
          container.textContent = 'No weapons';
        }
      }
    } catch {
      container.innerHTML = '<div style="color:#ff6666">Failed</div>';
    }
  }

  // Enable buttons if user has access (owner or partner)
  if (hasAccess) {
    infoTabBtn.onclick = showInfo;
    workforceTabBtn.onclick = showWorkforce;
    chatTabBtn.onclick = showChat;
    proposalsTabBtn.onclick = showProposals;
    if (instData.name === 'Defence Base') {
      weaponsTabBtn.style.display = 'inline-block';
      weaponsTabBtn.onclick = showWeapons;
    } else {
      weaponsTabBtn.style.display = 'none';
      weaponsTabBtn.onclick = null;
    }
  } else {
    infoTabBtn.onclick = null;
    workforceTabBtn.onclick = null;
    chatTabBtn.onclick = null;
    proposalsTabBtn.onclick = null;
    weaponsTabBtn.onclick = null;
    weaponsTabBtn.style.display = 'none';
  }

  function closePopup() {
    popup.style.display = 'none';
    institutionPopupOpen = false;
    document.removeEventListener('keydown', escHandler);
    if (chatInterval) {
      clearInterval(chatInterval);
      chatInterval = null;
    }
    infoDiv.classList.remove('hidden');
    workforceDiv.classList.add('hidden');
    chatDiv.classList.add('hidden');
    proposalsDiv.classList.add('hidden');
    weaponsDiv.classList.add('hidden');
  }

  function escHandler(e) {
    if (e.key === 'Escape') closePopup();
  }

  popup.style.display = 'block';
  popup.focus();
  institutionPopupOpen = true;
  showInfo();
  document.addEventListener('keydown', escHandler);
  closeBtn.onclick = closePopup;
  const ownerLink = document.getElementById('owner-click');
  if (ownerLink && (isOwner || hasAccess)) ownerLink.onclick = showWorkforce;
}

function showWorkerProfile(worker, institutionId, isHired = false, index = null) {
  const overlay = document.getElementById('worker-profile-overlay');
  const nameEl = document.getElementById('profile-name');
  const roleEl = document.getElementById('profile-role');
  const imageEl = document.getElementById('profile-image');
  const wageEl = document.getElementById('profile-wage');
  const hydrationEl = document.getElementById('profile-hydration');
  const oxygenEl = document.getElementById('profile-oxygen');
  const healthEl = document.getElementById('profile-health');
  const backstoryEl = document.getElementById('profile-backstory');
  const resumeEl = document.getElementById('profile-resume');
  const hireBtn = document.getElementById('profile-hire-btn');
  const fireBtn = document.getElementById('profile-fire-btn');

  nameEl.textContent = worker.name + (worker.director ? ' \u2B50' : '');
  roleEl.textContent = worker.role;
  imageEl.src = worker.image;
  wageEl.textContent = worker.wage;
  hydrationEl.textContent = worker.effects?.hydration || 0;
  oxygenEl.textContent = worker.effects?.oxygen || 0;
  healthEl.textContent = worker.effects?.health || 0;

  backstoryEl.innerHTML = '';
  if (Array.isArray(worker.backstory)) {
    const ul = document.createElement('ul');
    worker.backstory.forEach(it => {
      const li = document.createElement('li');
      li.textContent = it;
      ul.appendChild(li);
    });
    backstoryEl.appendChild(ul);
  } else if (typeof worker.backstory === 'string') {
    const lines = worker.backstory.split(/\n|\\n/);
    const ul = document.createElement('ul');
    lines.forEach(line => {
      line = line.trim();
      if (line) {
        const li = document.createElement('li');
        li.textContent = line.replace(/^[-*‚Ä¢]\s*/, '');
        ul.appendChild(li);
      }
    });
    backstoryEl.appendChild(ul);
  }

  resumeEl.innerHTML = '';
  if (Array.isArray(worker.resume)) {
    const ul = document.createElement('ul');
    worker.resume.forEach(it => {
      const li = document.createElement('li');
      li.textContent = it;
      ul.appendChild(li);
    });
    resumeEl.appendChild(ul);
  } else if (typeof worker.resume === 'string') {
    const lines = worker.resume.split(/\n|\\n/);
    const ul = document.createElement('ul');
    lines.forEach(line => {
      line = line.trim();
      if (line) {
        const li = document.createElement('li');
        li.textContent = line.replace(/^[-*‚Ä¢]\s*/, '');
        ul.appendChild(li);
      }
    });
    resumeEl.appendChild(ul);
  }

  if (isHired) {
    hireBtn.style.display = 'none';
    fireBtn.style.display = 'block';
    fireBtn.onclick = async () => {
      try {
        const res = await fetch(`/api/workforce/fire/${institutionId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ index })
        });
        if (res.ok) {
          const inst = institutionDataMap[institutionId];
          if (inst && Array.isArray(inst.workforce)) {
            inst.workforce.splice(index, 1);
          }
          const carousel = document.getElementById('popup-workforce-carousel');
          if (carousel && carousel.children[index]) {
            carousel.removeChild(carousel.children[index]);
            if (carousel.children.length === 0) {
              carousel.textContent = 'No workforce';
            }
          }
          overlay.classList.add('hidden');
        } else {
          alert('Failed to fire worker');
        }
      } catch (err) {
        alert('Failed to fire worker');
      }
    };
  } else {
    hireBtn.style.display = 'block';
    fireBtn.style.display = 'none';
    hireBtn.onclick = async () => {
      try {
        const res = await fetch(`/api/workforce/hire/${institutionId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ worker })
        });
        if (res.ok) {
          overlay.classList.add('hidden');
          const container = document.getElementById('workforce-container');
          const cards = container.querySelectorAll('.worker-card');
          cards.forEach(card => {
            if (card.querySelector('.card-inner').textContent.includes(worker.name)) {
              container.removeChild(card);
            }
          });
          if (container.children.length === 0) {
            container.innerHTML = '<div style="color: #fff; text-align: center;">All applicants hired!</div>';
          }
        } else {
          alert('Failed to hire worker');
        }
      } catch (err) {
        alert('Failed to hire worker');
      }
    };
  }

  overlay.classList.remove('hidden');

  document.getElementById('profile-close').onclick = () => {
    overlay.classList.add('hidden');
  };

  overlay.onclick = (e) => {
    if (e.target === overlay) {
      overlay.classList.add('hidden');
    }
  };
}

  function updateSinking(dt) {
    for (let i = sinking.length - 1; i >= 0; i--) {
      const s = sinking[i];
      s.t += dt * 5;
      if (s.emit > 0.05 || s.t === 0) {
        const box = new THREE.Box3().setFromObject(s.obj);
        const cx = (box.min.x + box.max.x) / 2;
        const cz = (box.min.z + box.max.z) / 2;
        const y = box.min.y;
        const points = [
          new THREE.Vector3(box.min.x, y, box.min.z),
          new THREE.Vector3(box.min.x, y, box.max.z),
          new THREE.Vector3(box.max.x, y, box.min.z),
          new THREE.Vector3(box.max.x, y, box.max.z),
          new THREE.Vector3(cx, y, box.min.z),
          new THREE.Vector3(cx, y, box.max.z),
          new THREE.Vector3(box.min.x, y, cz),
          new THREE.Vector3(box.max.x, y, cz)
        ];
        points.forEach(p => emitDustParticle(p, 3));
        s.emit = 0;
      }
      s.emit += dt;
      const t = Math.min(s.t, 1);
      s.obj.position.y = THREE.MathUtils.lerp(s.start, s.end, t);
      if (t >= 1) {
        sinking.splice(i, 1);
      }
    }
  }

  function updateInstitutionBoxes() {
    institutionBoxes.forEach(entry => {
      const obj = institutionsMap[entry.id];
      if (obj) updateBuildingFootprint(entry.box, obj);
    });
  }

  function updateConstructionBoxes() {
    constructionBoxes.forEach(entry => {
      const list = constructionMap[entry.id];
      const c = list && list[entry.index];
      const obj = c && (c.scaff || c.final);
      if (obj) updateBuildingFootprint(entry.box, obj);
    });
  }

  function handlePendingRemotePlayers() {
    if (!model) return;
    pendingRemotePlayers.forEach(p => createRemotePlayer(p.id, p.state));
    pendingRemotePlayers.length = 0;
  }

  function sendState() {
    if (!socket || socket.readyState !== WebSocket.OPEN || !model) return;
    socket.send(JSON.stringify({
      type: 'state',
      position: [model.position.x, model.position.y, model.position.z],
      rotation: model.rotation.y,
      moving: isMovingForward,
      running: isRunning,
      health,
      hydration,
      oxygen,
      money: playerMoney
    }));
  }

  function sendDestroyInstitution(id) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: 'destroyInstitution', id }));
  }





  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x775533, 1.2);
  scene.add(hemiLight);

  // Main directional light (sun) - IMPROVED SHADOW SETTINGS
  const sun = new THREE.DirectionalLight(0xffffff, 1.8);
  sun.position.set(20, 30, 15);
  sun.castShadow = true;

  // Improved shadow quality
  sun.shadow.mapSize.width = 4096; // Increased from 2048
  sun.shadow.mapSize.height = 4096; // Increased from 2048
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200; // Extended range
  sun.shadow.camera.left = -100;
  sun.shadow.camera.right = 100;
  sun.shadow.camera.top = 100;
  sun.shadow.camera.bottom = -100;
  sun.shadow.bias = -0.0005; // Helps prevent shadow acne

  scene.add(sun);


  // Uncomment to visualize shadow camera (helpful for debugging)
  // const helper = new THREE.CameraHelper(sun.shadow.camera);
  // scene.add(helper);

  // Additional directional light for better terrain illumination
  const secondaryLight = new THREE.DirectionalLight(0xffd6a5, 1.0); // Warm light
  secondaryLight.position.set(-15, 20, -10); // From opposite direction of sun
  secondaryLight.castShadow = false; // Optional shadow from secondary light
  scene.add(secondaryLight);

  // --- Day/Night Cycle Settings ---
  const DAY_DURATION = 600;   // seconds of daylight
  const NIGHT_DURATION = 600; // seconds of night
  const CYCLE_DURATION = DAY_DURATION + NIGHT_DURATION;
  const SUN_RADIUS = 50;
  const MAX_SUN_INTENSITY = 1.8;
  let dayNightTimer = 0;
  const daySkyColor = new THREE.Color(marsSkyColor);
  const nightSkyColor = new THREE.Color(0x050505);

  function updateDayNightCycle(dt) {
    dayNightTimer = (dayNightTimer + dt) % CYCLE_DURATION;
    const angle = (dayNightTimer / CYCLE_DURATION) * Math.PI * 2;

    // Sun position follows a circular path
    sun.position.set(Math.cos(angle) * SUN_RADIUS, Math.sin(angle) * SUN_RADIUS, 0);
    sun.lookAt(0, 0, 0);

    // Daylight intensity based on sun height
    const daylight = Math.max(0, Math.sin(angle));
    sun.intensity = daylight * MAX_SUN_INTENSITY;
    secondaryLight.intensity = daylight;
    hemiLight.intensity = 0.2 + daylight;

    const skyColor = daySkyColor.clone().lerp(nightSkyColor, 1 - daylight);
    renderer.setClearColor(skyColor);
    scene.fog.color.copy(skyColor);
  }

  // Ground Textures - Load first before terrain
  const textureLoader = new THREE.TextureLoader();
  let diffuseMap = null;
  let bumpMap = null;
  let specMap = null;
  const baseTextureRepeat = 1000; // Base repeat factor for the texture

  // Track texture loading status
  const texturesLoaded = {
    diffuse: false,
    bump: false,
    spec: false
  };

  // Function to check if all textures are loaded and apply them
  function checkTexturesAndApply() {
    if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
      if (gltfTerrain) {
        applyTexturesToTerrain(gltfTerrain);
      }
    }
  }

  // Load diffuse texture (base color)
  textureLoader.load(
    'mars_ground.png',
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      diffuseMap = texture;
      texturesLoaded.diffuse = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.diffuse = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load bump map
  textureLoader.load(
    'mars_ground_bump.png', // Adjust filename to match your bump map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      bumpMap = texture;
      texturesLoaded.bump = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.bump = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load specular map
  textureLoader.load(
    'mars_ground_spec.png', // Adjust filename to match your specular map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      specMap = texture;
      texturesLoaded.spec = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.spec = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load dust particle texture
  let dustTexture;
  textureLoader.load(
    'dust.png',
    (texture) => {
      dustTexture = texture;
      // Initialize dust particles system once texture is loaded
      initDustParticles();
    },
    undefined,
    (error) => {
      // Create a fallback texture - a simple circle
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 24;

      // Draw a simple radial gradient for the particle
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
      gradient.addColorStop(0, 'rgba(255, 230, 200, 1.0)');
      gradient.addColorStop(0.5, 'rgba(230, 200, 170, 0.5)');
      gradient.addColorStop(1, 'rgba(200, 170, 140, 0.0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();

      dustTexture = new THREE.CanvasTexture(canvas);
      initDustParticles();
    }
  );

  // Helper function to apply textures to terrain
  function applyTexturesToTerrain(terrain) {
    terrain.traverse(o => {
      if (o.isMesh) {
        // Create a new material with all textures
        o.material = new THREE.MeshStandardMaterial({
          map: diffuseMap,
          bumpMap: bumpMap,
          bumpScale: 2.3, // Adjust bump intensity
          roughnessMap: specMap, // In PBR, specular is controlled by roughness
          roughness: 5,
          metalness: 0.0,
          color: 0xDC916E // White color to allow texture to show properly
        });
        o.receiveShadow = true; // Make sure terrain receives shadows
        o.material.needsUpdate = true;
      }
    });
  }

  // --- DUST PARTICLES SYSTEM ---
  const MAX_PARTICLES = 300;
  let particleSystem;
  let dustParticles = []; // Array of active particles

  function initDustParticles() {

    // Create a simple points material using the dust texture
    const particleMaterial = new THREE.PointsMaterial({
      size: 1.0,
      map: dustTexture,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true,
      opacity: 0.6,
      sizeAttenuation: true,
      color: 0xbbaa99 // Dusty color
    });

    // Create geometry for the particles
    const particlesGeometry = new THREE.BufferGeometry();

    // Create arrays for positions, sizes, and colors
    const positions = new Float32Array(MAX_PARTICLES * 3);
    const sizes = new Float32Array(MAX_PARTICLES);
    const colors = new Float32Array(MAX_PARTICLES * 3);

    // Initialize all particles to be far below the scene (inactive)
    for (let i = 0; i < MAX_PARTICLES; i++) {
      positions[i * 3] = 0;
      positions[i * 3 + 1] = -1000; // Far below the scene
      positions[i * 3 + 2] = 0;

      sizes[i] = 0;

      // Slightly vary the color of each particle
      const dustColor = new THREE.Color(0xbbaa99);
      dustColor.r *= 0.8 + Math.random() * 0.4;
      dustColor.g *= 0.8 + Math.random() * 0.4;
      dustColor.b *= 0.8 + Math.random() * 0.4;

      colors[i * 3] = dustColor.r;
      colors[i * 3 + 1] = dustColor.g;
      colors[i * 3 + 2] = dustColor.b;

      // Create particle object
      dustParticles.push({
        position: new THREE.Vector3(0, -1000, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        size: 0,
        color: dustColor,
        life: 0,
        maxLife: 2.0,
        active: false,
        index: i
      });
    }

    // Add attributes to the buffer geometry
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create the particle system
    particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    particleSystem.frustumCulled = false; // Prevent particles from disappearing at edge of view
    scene.add(particleSystem);

  }

  // Create new active particles
  function emitDustParticle(position, count = 5) {
    if (!particleSystem) {
      return;
    }

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;

    let emitted = 0;

    // Find inactive particles to reuse
    for (let i = 0; i < dustParticles.length && emitted < count; i++) {
      const particle = dustParticles[i];

      if (!particle.active) {
        // Random offset around the foot position
        const offsetX = (Math.random() - 0.5) * 0.8;
        const offsetZ = (Math.random() - 0.5) * 0.8;

        // Position the particle slightly above ground level
        particle.position.set(
          position.x + offsetX,
          position.y + 0.1, // Higher above ground for visibility
          position.z + offsetZ
        );

        // Random velocity
        particle.velocity.set(
          (Math.random() - 0.5) * 0.6, // More horizontal spread
          Math.random() * 0.5 + 0.2,   // More vertical rise
          (Math.random() - 0.5) * 0.6  // More horizontal spread
        );

        particle.maxLife = 1.0 + Math.random() * 1.5; // 1.0-2.5 seconds
        particle.life = 0;
        particle.size = 0.5;  // Starting size (larger for better visibility)
        particle.active = true;

        // Update the particle data in the buffers
        const idx = particle.index;
        positions[idx * 3] = particle.position.x;
        positions[idx * 3 + 1] = particle.position.y;
        positions[idx * 3 + 2] = particle.position.z;

        sizes[idx] = particle.size;

        emitted++;
      }
    }

    // Mark attributes as needing update
    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.size.needsUpdate = true;

  }

  // Update particles every frame
  function updateParticles(dt) {
    if (!particleSystem) return;

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;
    let needsUpdate = false;

    // Update each active particle
    for (let i = 0; i < dustParticles.length; i++) {
      const particle = dustParticles[i];

      if (particle.active) {
        // Update particle life
        particle.life += dt;

        if (particle.life >= particle.maxLife) {
          // Deactivate the particle
          particle.active = false;

          // Move it far below scene
          particle.position.y = -1000;
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          sizes[i] = 0;
          needsUpdate = true;
        } else {
          // Calculate life progress (0 to 1)
          const t = particle.life / particle.maxLife;

          // Update position with velocity
          particle.position.x += particle.velocity.x * dt;
          particle.position.y += particle.velocity.y * dt;
          particle.position.z += particle.velocity.z * dt;

          // Air resistance / drag
          particle.velocity.multiplyScalar(0.95);

          // Gravity effect - slow down ascent
          particle.velocity.y -= 0.1 * dt;

          // Calculate size and opacity based on life cycle
          // Start small, grow, then shrink
          let size;
          if (t < 0.2) {
            // Grow quickly at start
            size = (t / 0.2) * 2.0;
          } else if (t > 0.8) {
            // Shrink at end
            size = 2.0 * (1.0 - (t - 0.8) / 0.2);
          } else {
            // Maintain size in middle
            size = 2.0;
          }

          // Update size (larger and more visible)
          particle.size = size;
          sizes[i] = size;

          // Update position in buffer
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          needsUpdate = true;
        }
      }
    }

    // Only update buffers if needed
    if (needsUpdate) {
      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.geometry.attributes.size.needsUpdate = true;
    }
  }

  // --- PHYSICS AND GRAVITY SETTINGS ---
  const gravity = 3.7; // Mars gravity (lower than Earth's 9.8)
  const groundCheckDistance = 2.0; // Slightly increased for stability
  let velocity = new THREE.Vector3(0, 0, 0);
  let onGround = false;
  let groundY = null; // To track stable ground height
  const groundDamping = 1; // Dampening factor (0.0 to 1.0) - higher means less bounce
  const initialFallHeight = 100; // Reasonable height to start falling from

  // Raycaster for ground detection
  const raycaster = new THREE.Raycaster();

  // --- LOAD GLTF GROUND MODEL ---
  const groundLoader = new GLTFLoader();
  let gltfTerrain;
  const terrainScaleFactor = 50; // Adjust this to scale your terrain

  // Array to store all terrain meshes for raycasting
  const terrainMeshes = [];

  // Spatial grid for terrain chunks
  const terrainGrid = new Map();
  const GRID_SIZE = 50;

  function addTerrainToGrid(mesh) {
    const box = new THREE.Box3().setFromObject(mesh);
    const minX = Math.floor(box.min.x / GRID_SIZE);
    const maxX = Math.ceil(box.max.x / GRID_SIZE);
    const minZ = Math.floor(box.min.z / GRID_SIZE);
    const maxZ = Math.ceil(box.max.z / GRID_SIZE);

    for (let x = minX; x <= maxX; x++) {
      for (let z = minZ; z <= maxZ; z++) {
        const key = `${x},${z}`;
        if (!terrainGrid.has(key)) terrainGrid.set(key, []);
        terrainGrid.get(key).push(mesh);
      }
    }
  }

  function getNearbyTerrain(position) {
    const gridX = Math.floor(position.x / GRID_SIZE);
    const gridZ = Math.floor(position.z / GRID_SIZE);
    const nearby = [];

    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        const key = `${gridX + dx},${gridZ + dz}`;
        if (terrainGrid.has(key)) {
          nearby.push(...terrainGrid.get(key));
        }
      }
    }

    return nearby;
  }

  groundLoader.load(
    'terrain.gltf', // Replace this with the path to your ground GLTF file
    (gltf) => {
      gltfTerrain = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!gltfTerrain) return;
      addPointLightsFromGLTF(gltf);

      gltfTerrain.scale.set(terrainScaleFactor, terrainScaleFactor, terrainScaleFactor);

      // Optional: Adjust terrain position if needed
      // gltfTerrain.position.y = -someValueToCorrect;

      gltfTerrain.traverse(o => {
        if (o.isMesh) {
          o.receiveShadow = true;
          o.castShadow = false;

          // Add mesh to our array for raycasting
          terrainMeshes.push(o);
          addTerrainToGrid(o);
        }
      });

      // Apply textures if they're already loaded
      if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
        applyTexturesToTerrain(gltfTerrain);
      }

      scene.add(gltfTerrain);

      // Position model on the terrain if it's already loaded
      if (model) {
        findGroundBelow();
      }
    },
    undefined,
    (error) => {
      // Create a fallback terrain with some hills
      createFallbackTerrain();
    }
  );

  // Create a fallback procedural terrain with variation for testing
  function createFallbackTerrain() {
    // Create a larger, more detailed fallback ground with some hills
    const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);

    // Add some hills and valleys
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
      // Skip the edges to keep them flat
      const x = vertices[i];
      const z = vertices[i+2];
      if (Math.abs(x) < 90 && Math.abs(z) < 90) {
        // Create some hills using sine waves
        vertices[i+1] = Math.sin(x * 0.1) * 3 + Math.sin(z * 0.1) * 3;
      }
    }

    // Important: update normals after modifying vertices
    groundGeometry.computeVertexNormals();

    // Create material with available textures
    const groundMaterial = new THREE.MeshStandardMaterial({
      roughness: 0.8,
      metalness: 0.2
    });

    // Apply textures to fallback terrain if available
    if (diffuseMap) {
      groundMaterial.map = diffuseMap;
      groundMaterial.map.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    } else {
      groundMaterial.color.set(0x553311);
    }

    if (bumpMap) {
      groundMaterial.bumpMap = bumpMap;
      groundMaterial.bumpScale = 0.5;
      groundMaterial.bumpMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    if (specMap) {
      groundMaterial.roughnessMap = specMap;
      groundMaterial.roughnessMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    const fallbackGround = new THREE.Mesh(groundGeometry, groundMaterial);
    fallbackGround.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    fallbackGround.receiveShadow = true;
    scene.add(fallbackGround);

    // Add to terrainMeshes for raycasting
    terrainMeshes.push(fallbackGround);
    addTerrainToGrid(fallbackGround);


    // Position the model if it's already loaded
    if (model) {
      findGroundBelow();
    }
  }

  // Player model and animations
  let model, mixer;
  let runAction, walkAction, idleAction, dieAction, flagPlantAction;
  let activeAction;
  const modelScale = 1.2;
  const characterHeight = 1.8 * modelScale; // Approximate height of character
  const characterRadius = 0.2 * modelScale; // Radius used for collision checks
  let playerAnimations = null;

  // Track foot positions for dust particles
  const footPositions = {
    left: new THREE.Vector3(),
    right: new THREE.Vector3(),
    lastEmitTime: 0
  };

  // Load player model
  new GLTFLoader().load(
    'character.glb',
    gltf => {
      model = gltf.scene || (gltf.scenes && gltf.scenes[0]);
      if (!model) return;
      addPointLightsFromGLTF(gltf);
      model.scale.set(modelScale, modelScale, modelScale);
      model.rotation.y =0
      // Setup shadow casting
      model.traverse(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = false;

          const oldMat = o.material;
          if (oldMat && !oldMat.isMeshStandardMaterial) {
            o.material = new THREE.MeshStandardMaterial({
              map: oldMat.map || null,
              color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
              metalness: 0.2,
              roughness: 0.8,
              skinning: !!o.isSkinnedMesh
            });
          }
        }
      });
      scene.add(model);

      // Footstep audio attached to the player
      footstepSound = new THREE.PositionalAudio(listener);
      audioLoader.load('walking.mp3', buffer => {
        footstepSound.setBuffer(buffer);
        footstepSound.setLoop(true);
        footstepSound.setRefDistance(5);
        footstepSound.setVolume(0);
        footstepSound.play();
      });
      model.add(footstepSound);

      // Debug: log when player model is loaded and its starting position
      if (DEBUG_LOG) {
        console.log('[DEBUG] Player model loaded', {
          position: {
            x: startPosition[0],
            y: startPosition[1],
            z: startPosition[2]
          }
        });
      }

      // Position the model based on saved state
      model.position.set(startPosition[0], startPosition[1], startPosition[2]);

      // Setup animations
      mixer = new THREE.AnimationMixer(model);
      const animations = gltf.animations;
      idleAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'idle'));
      walkAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'walk'));
      runAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'run'));
      dieAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'die'));
      flagPlantAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'target'));
      if (flagPlantAction) {
        flagPlantAction.setLoop(THREE.LoopOnce, 1);
        flagPlantAction.clampWhenFinished = true;
      }
      if (dieAction) {
        dieAction.setLoop(THREE.LoopOnce, 1);
        dieAction.clampWhenFinished = true;
      }
      playerAnimations = animations;


      // Set up animation events for dust particles
      if (runAction || walkAction) {
        // Add an event that fires at specific points in animation
        // (these numbers would need adjustment based on the actual animation)
        const leftFootStep = 0.3; // 30% through animation
        const rightFootStep = 0.8; // 80% through animation

        // Set up animation events using mixer
        mixer.addEventListener('loop', function(e) {
          if ((e.action === runAction || e.action === walkAction) && isMovingForward && onGround) {
            // Calculate foot positions and emit dust at each step
            calculateFootPositions();
          }
        });
      }

      activeAction = idleAction || walkAction || runAction;
      if (activeAction) activeAction.play();

      // If terrain is already loaded, we can find the ground
      if (terrainMeshes.length > 0) {
        findGroundBelow();
      }
      handlePendingRemotePlayers();
    },
    undefined,
  );

  // Calculate foot positions based on model
  function calculateFootPositions() {
    if (!model) return;

    // Get model's world position
    const modelPosition = model.position.clone();
    const modelDirection = new THREE.Vector3(0, 0, -1);
    modelDirection.applyQuaternion(model.quaternion);

    // Calculate basic foot positions (slightly behind model for walking)
    // This is an approximation - would be better with actual bone positions
    const footOffset = 0.5 * modelScale;

    // Position for left foot
    footPositions.left.set(
      modelPosition.x - modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z + modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Position for right foot
    footPositions.right.set(
      modelPosition.x + modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z - modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Emit particles at both feet
    emitDustParticle(footPositions.left, 10); // Emit more particles for better visibility
    emitDustParticle(footPositions.right, 10);

  }

  /**
   * Finds the ground below the character without teleporting to it
   * Just identifies where the ground is for physics to work with
   */
  function findGroundBelow() {
    if (!model || terrainMeshes.length === 0) return;

    // Use the actual current position of the model
    const origin = model.position.clone();

    // Cast ray downward from current position
    raycaster.set(
      origin,
      new THREE.Vector3(0, -1, 0) // Direction straight down
    );

    const intersects = raycaster.intersectObjects(getNearbyTerrain(origin), true);

    if (intersects.length > 0) {
      // We found ground - but we won't teleport to it
      // Just let gravity do its work in the animation loop

      // We're not on ground yet - we're still falling
      onGround = false;
    } else {
    }
  }

  // Input state
  const keys = { w: false, a: false, s: false, d: false, arrowup: false, arrowleft: false, arrowright: false, arrowdown: false, space: false, shift: false };
    window.addEventListener('keydown', e => {
      if (institutionPopupOpen || hallFormOpen) return;
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = true;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
    if (e.code === 'KeyK') {
      if (DEBUG_LOG) console.log('[DEBUG] Key K pressed');
      fireAllWeapons();
    } else if (e.code === 'KeyT') {
      if (DEBUG_LOG) console.log('[DEBUG] Key T pressed');
      plantFlag();
    }
  });
    window.addEventListener('keyup', e => {
      if (institutionPopupOpen || hallFormOpen) return;
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = false;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
  });

  // Camera and movement settings
  const camOffset = new THREE.Vector3(0, 2.0 * modelScale, -5.0 * modelScale);
  const modelLookAtHeight = 1.5 * modelScale;
  const clock = new THREE.Clock();
  let isMovingForward = false;
  let isRunning = false;
  const walkSpeed = 3.0 * modelScale;
  const runSpeed = 6.0 * modelScale;
  let lastPosition = new THREE.Vector3();
  let timeSinceLastEmit = 0;

  function switchAnimation(actionToPlay) {
    if (activeAction === actionToPlay || !actionToPlay) return;
    if (activeAction) activeAction.fadeOut(0.2);
    actionToPlay.reset().fadeIn(0.2).play();
    activeAction = actionToPlay;
  }

  /**
   * Checks if character is in contact with the ground
   * Called every frame in the animation loop
   */
  function checkGroundContact() {
    if (!model) return;

    // Origin is at character's feet plus half height (center of character)
    const origin = model.position.clone();
    origin.y += characterHeight / 2;

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(getNearbyTerrain(origin), true);

    // Check if we're on or near ground
    if (intersects.length > 0 && intersects[0].distance <= groundCheckDistance) {
      const groundPosition = intersects[0].point.y;

      // Handle initial ground contact
      if (!onGround) {
          velocity.y = 0;
          onGround = true;

      } else {
        // Already on ground - stabilize position with smooth interpolation
        if (groundY === null) {
          groundY = groundPosition;
        } else {
          // Smoothly interpolate ground height to prevent jitter
          groundY = groundY * 0.9 + groundPosition * 0.1;
        }

        // Smoothly set character position
        model.position.y = groundY;
        velocity.y = 0;
      }
    } else {
      // Not touching ground
      onGround = false;
      groundY = null;
    }
  }

  // Update alignment with terrain after horizontal movement
  function updateTerrainAlignment() {
    if (!model) return;

    // Only check terrain alignment if we're on the ground
    if (!onGround) return;

    // Origin at character's feet
    const origin = model.position.clone();
    origin.y += 0.5 * characterHeight; // Start from middle of character

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(getNearbyTerrain(origin), true);

    if (intersects.length > 0) {
      const targetY = intersects[0].point.y;

      // Smooth interpolation of height change for walking on uneven terrain
      if (groundY === null) {
        groundY = targetY;
      } else {
        // Adjust smoothing factor based on how fast we're moving
        // More smoothing (smaller factor) for faster movement to reduce jitter
        const smoothFactor = isMovingForward ? 0.15 : 0.3;
        groundY = groundY * (1 - smoothFactor) + targetY * smoothFactor;
      }

      // Apply smoothed position
      model.position.y = groundY;
    }
  }

  function updateCamera(dt) {
    if (!model) return;

    const modelWorldPosition = new THREE.Vector3();
    model.getWorldPosition(modelWorldPosition);

    // Apply camera offset in model's local space
    const desiredCamPos = modelWorldPosition.clone().add(
      camOffset.clone().applyQuaternion(model.quaternion)
    );

    // Smoother camera lerp
    camera.position.lerp(desiredCamPos, 5 * dt);

    // Look at point slightly above character's feet
    const lookAtPoint = modelWorldPosition.clone();
    lookAtPoint.y += modelLookAtHeight;
    camera.lookAt(lookAtPoint);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    updateDayNightCycle(dt);

    // Update particles
    updateParticles(dt);
    updateProjectiles(dt);
    updateSinking(dt);
    updateInstitutionBoxes();
    updateConstructionBoxes();

    if (mixer) mixer.update(dt);
    for (const id in remotePlayers) {
      remotePlayers[id].mixer.update(dt);
    }
    for (const id in institutionMixers) {
      institutionMixers[id].update(dt);
    }
    for (const id in weaponMixers) {
      const arr = weaponMixers[id];
      if (Array.isArray(arr)) arr.forEach(m => m.update(dt));
    }
    if (ghostMixer) ghostMixer.update(dt);

    if (model && terrainMeshes.length > 0) {
        // PHYSICS - Apply gravity if not on ground
        if (!onGround) {
            velocity.y -= gravity * dt;

            // Apply velocity (for falling)
            model.position.y += velocity.y * dt;

            // Force idle animation when in the air
            if (idleAction && activeAction !== idleAction) {
                switchAnimation(idleAction);
                // We're not moving forward when in the air
                isMovingForward = false;
            }
        }

        // Check if on ground after applying gravity
        checkGroundContact();

        // Controls and movement - only process when on ground
        if ((idleAction || walkAction || runAction) && onGround) {
            // Save last position for movement detection
            lastPosition.copy(model.position);

            const turnSpeed = (Math.PI); // Adjusted turn speed a bit

            let wantsToMoveForward = keys.w || keys.up;
            let wantsToMoveBackward = keys.s || keys.down;
            let turnLeft = keys.a || keys.left;
            let turnRight = keys.d || keys.right;

            // Handle turning
            if (turnLeft) model.rotation.y += turnSpeed * dt;
            if (turnRight) model.rotation.y -= turnSpeed * dt;

            // Movement
            let moving = false;
            let moveDir = new THREE.Vector3(0, 0, 0);
            let moveAction = idleAction;

            if (wantsToMoveForward) {
                // Fixed direction to go forward from model perspective
                moveDir.z = 1;
                moving = true;
                isRunning = keys.shift;
                moveAction = isRunning ? runAction : walkAction;
            } else if (wantsToMoveBackward) {
                moveDir.z = -0.5;
                moving = true;
                isRunning = false;
                moveAction = walkAction || runAction;
            }

            // Apply movement in model's local direction
            if (moving) {
                const speed = isRunning ? runSpeed : walkSpeed;
                if (activeAction !== moveAction && moveAction) {
                    switchAnimation(moveAction);
                }
                isMovingForward = true;

                // Transform direction to world space
                moveDir.applyQuaternion(model.quaternion);
                moveDir.normalize();

                // Store current position before movement
                const oldPos = model.position.clone();

                const proposed = model.position.clone().add(moveDir.clone().multiplyScalar(speed * dt));
                let blocked = false;
                const sphereCenter = proposed.clone();
                sphereCenter.y += characterHeight / 2;
                const sphere = new THREE.Sphere(sphereCenter, characterRadius);
                institutionBoxes.forEach(entry => {
                    if (sphereIntersectsFootprint(entry.box, sphere)) blocked = true;
                });
                constructionBoxes.forEach(entry => {
                    if (sphereIntersectsFootprint(entry.box, sphere)) blocked = true;
                });
                if (!blocked) {
                    model.position.copy(proposed);
                }

                // Update terrain alignment after horizontal movement
                if (onGround) {
                    updateTerrainAlignment();

                    // Emit dust particles when walking on ground
                    timeSinceLastEmit += dt;
                    if (timeSinceLastEmit > 0.1) { // More frequent emission (was 0.2)
                        calculateFootPositions();
                        timeSinceLastEmit = 0;

                        // Debug log for dust emission
                        if (isMovingForward && onGround) {
                        }
                    }
                }
            } else if (isMovingForward && idleAction) {
                // Switch to idle when not moving
                switchAnimation(idleAction);
                isMovingForward = false;
                isRunning = false;
            }

            if (footstepSound) {
                const vol = (isMovingForward && onGround) ? 1 : 0;
                footstepSound.setVolume(vol);
            }
        }

        if (model.position.y < -300) {
          model.position.y = 40;
          velocity.y = 0;
          groundY = null;
          onGround = false;
        }

        // Camera follow
        updateCamera(dt);
        updateGhostInstitution();
        if (!dead) {
          sendState();
          updateStats();
          institutionFrame++;
          if (institutionFrame >= INSTITUTION_INTERVAL_FRAMES) {
            applyInstitutionEffects();
            institutionFrame = 0;
          }
        }
        else {
          sendState();
        }
    }

    // Debug rendering to visualize particle positions
    if (particleSystem && particleSystem.geometry) {
      const positions = particleSystem.geometry.attributes.position.array;
      const sizes = particleSystem.geometry.attributes.size.array;

      // Count active particles
      let activeCount = 0;
      for (let i = 0; i < dustParticles.length; i++) {
        if (dustParticles[i].active) activeCount++;
      }

      if (activeCount > 0 && model) {
      }
    }

    // Render using composer for bloom effect
  composer.render();
}

// Planet Hall functionality
let currentBoardMembers = [];

function showPlanetHallPopup() {
  const popup = document.getElementById('planethall-popup');
  popup.style.display = 'block';
  loadBoardMembers();
  loadHallChat();
  loadPolicies();
  loadReferendum();
}

async function loadBoardMembers() {
  try {
    const res = await fetch('/api/planethall/board');
    const data = await res.json();
    currentBoardMembers = data.boardMembers || [];
    const container = document.getElementById('board-members');
    container.innerHTML = '';
    if (currentBoardMembers.length === 0) {
      container.innerHTML = '<div style="color:#888;">No board members elected yet</div>';
      return;
    }
    currentBoardMembers.forEach(m => {
      const div = document.createElement('div');
      div.className = 'board-member';
      div.innerHTML = `<div style="font-weight:bold;">${m.name}</div><div style="font-size:12px;color:#888;">Elected: ${new Date(m.electedDate).toLocaleDateString()}</div>`;
      container.appendChild(div);
    });
    const isMember = currentBoardMembers.some(m => m.email === playerEmail);
    document.getElementById('new-policy-btn').style.display = isMember ? 'block' : 'none';
  } catch (err) {
    console.error('Failed to load board members', err);
  }
}

async function loadHallChat() {
  try {
    const res = await fetch('/api/planethall/chat');
    const data = await res.json();
    const container = document.getElementById('hall-chat-messages');
    container.innerHTML = '';
    data.messages.forEach(m => {
      const div = document.createElement('div');
      div.className = 'hall-chat-message';
      div.innerHTML = `<strong>${m.name}:</strong> ${m.text}`;
      container.appendChild(div);
    });
    container.scrollTop = container.scrollHeight;
  } catch (err) {
    console.error('Failed to load chat', err);
  }
}

async function loadPolicies() {
  try {
    const res = await fetch('/api/planethall/policies');
    const data = await res.json();
    const container = document.getElementById('policies-list');
    container.innerHTML = '';
    data.policies.forEach(p => {
      const div = document.createElement('div');
      div.className = 'policy-item';
      let color = '#888';
      if (p.status === 'approved') color = '#4CAF50';
      else if (p.status === 'rejected') color = '#f44336';
      div.innerHTML = `<div style="font-weight:bold;">${p.title}</div><div style="font-size:12px;margin:4px 0;">${p.description}</div><div style="font-size:11px;color:#888;">Proposed by: ${p.proposedBy}</div><div style="font-size:11px;color:${color};">Status: ${p.status}</div>`;
      const isMember = currentBoardMembers.some(m => m.email === playerEmail);
      if (isMember && p.status === 'voting' && !p.votes[playerEmail]) {
        const voteDiv = document.createElement('div');
        voteDiv.style.marginTop = '8px';
        voteDiv.innerHTML = `<button onclick="votePolicy(${p.id}, true)">Approve</button> <button onclick="votePolicy(${p.id}, false)">Reject</button>`;
        div.appendChild(voteDiv);
      }
      container.appendChild(div);
    });
  } catch (err) {
    console.error('Failed to load policies', err);
  }
}

async function loadReferendum() {
  try {
    const res = await fetch('/api/planethall/referendum');
    const data = await res.json();
    const activeDiv = document.getElementById('active-referendum');
    const histDiv = document.getElementById('referendum-history');
    activeDiv.innerHTML = '';
    histDiv.innerHTML = '';
    if (data.active) {
      const yes = Object.values(data.active.votes || {}).filter(v => v).length;
      const no = Object.values(data.active.votes || {}).filter(v => !v).length;
      const total = data.active.totalWorkers || yes + no;
      activeDiv.innerHTML = `<div>Type: ${data.active.type}</div><div>Votes: ${yes+no}/${total}</div><div>Status: ${data.active.status}</div>`;
    } else {
      activeDiv.innerHTML = '<div style="color:#888;">No active referendum</div>';
    }
    if (Array.isArray(data.history) && data.history.length > 0) {
      data.history.slice(-5).forEach(r => {
        const d = document.createElement('div');
        d.style.marginTop = '6px';
        d.textContent = `${r.type} - ${r.status} (${r.result?.yes||0}/${r.result?.no||0})`;
        histDiv.appendChild(d);
      });
    } else {
      histDiv.innerHTML = '<div style="color:#888;">No referendum history</div>';
    }
  } catch (err) {
    document.getElementById('active-referendum').innerHTML = '<div style="color:#888;">Failed to load</div>';
  }
}

document.getElementById('planethall-close').onclick = () => {
  document.getElementById('planethall-popup').style.display = 'none';
  closeHallForms();
};

document.querySelectorAll('.hall-tab').forEach(tab => {
  tab.onclick = () => {
    document.querySelectorAll('.hall-tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    document.querySelectorAll('.hall-section').forEach(s => s.style.display = 'none');
    document.getElementById(`hall-${tab.dataset.section}`).style.display = 'block';
  };
});

document.getElementById('request-referendum').onclick = () => {
  openReferendumForm();
};
document.getElementById('new-policy-btn').onclick = () => {
  openPolicyForm();
};
document.getElementById('referendum-type').onchange = updateReferendumFields;
document.getElementById('referendum-submit').onclick = async e => {
  e.stopPropagation();
  const type = document.getElementById('referendum-type').value;
  let data = {};
  if (type === 'candidate') {
    data.email = document.getElementById('candidate-email').value.trim();
    data.name = document.getElementById('candidate-name').value.trim();
  } else if (type === 'fire') {
    data.email = document.getElementById('fire-email').value;
  } else {
    data.text = document.getElementById('policy-text').value.trim();
  }
  try {
      await fetch('/api/planethall/referendum', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, data, email: playerEmail })
      });
      closeHallForms();
  } catch (err) {
    console.error('Failed to start referendum', err);
  }
};

document.getElementById('policy-save').onclick = async e => {
  e.stopPropagation();
  const title = document.getElementById('policy-title').value.trim();
  const description = document.getElementById('policy-desc').value.trim();
  if (!title || !description) return;
  try {
      await fetch('/api/planethall/policies', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email: playerEmail, title, description })
      });
      closeHallForms();
    loadPolicies();
  } catch (err) {
    console.error('Failed to create policy', err);
  }
};

document.getElementById('hall-chat-send').onclick = async () => {
  const input = document.getElementById('hall-chat-input');
  const text = input.value.trim();
  if (!text) return;
  try {
    await fetch('/api/planethall/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email: playerEmail, text }) });
    input.value = '';
  } catch (err) {
    console.error('Failed to send chat', err);
  }
};

window.votePolicy = async function votePolicy(id, vote) {
  try {
    await fetch(`/api/planethall/policies/${id}/vote`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email: playerEmail, vote }) });
    loadPolicies();
  } catch (err) {
    console.error('Failed to vote', err);
  }
}

  // Start the game loop after login
  let gameStarted = false;
  function startGame() {
    if (gameStarted) return;
    document.body.appendChild(renderer.domElement);
    animate();
    gameStarted = true;
  }

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);

    ssaoPass.setSize(window.innerWidth, window.innerHeight);

    // Update bloom pass resolution
    bloomPass.resolution.set(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>