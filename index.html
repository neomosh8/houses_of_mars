<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mars Runner</title>
  <link rel="stylesheet" href="style.css">
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="login-container" class="login-container">
    <div class="login-box">
      <input type="email" id="login-email" placeholder="Email" />
      <button id="send-code">Send Code</button>
      <div id="code-section" class="hidden">
        <input type="text" id="login-code" placeholder="Code" />
        <button id="verify-code">Verify</button>
      </div>
      <div id="login-error"></div>
    </div>
  </div>
  <div id="money-display">Money: 0</div>
  <div id="status-panel">
    <div class="stat"><img id="health-img" /></div>
    <div class="stat"><img id="hydration-img" /></div>
    <div class="stat"><img id="oxygen-img" /></div>
  </div>
  <div id="low-oxygen-overlay"></div>
  <div id="death-overlay">
    <div>You died</div>
    <button id="respawn-btn">Respawn for 1000</button>
  </div>
  <div id="institution-panel" class="side-panel panel">
    <div class="panel-tab">Institutions</div>
    <div class="panel-content" id="institution-content"></div>
  </div>
    <div id="institution-popup" class="panel" tabindex="0">
    <div id="popup-close" >X</div>
    <div id="popup-info">
      <div id="popup-owner"></div>
      <div id="popup-resources"></div>
      <div id="popup-workforce-carousel" ></div>
    </div>
    <div id="popup-workforce" class="hidden">
      <div id="workforce-container" ></div>
    </div>
    <div id="popup-chat" class="hidden">
      <div id="chat-container"></div>
      <div id="chat-input-row">
        <input id="chat-input" type="text" placeholder="Type message" />
        <button id="chat-send">Send</button>
      </div>
    </div>
    <div id="popup-proposals" class="hidden">
      <div id="proposals-container"></div>
    </div>
    <div id="popup-weapons" class="hidden">
      <div id="weapons-container"></div>
    </div>
          <div class="popup-actions">
      <button id="info-tab-btn">Info</button>
      <button id="workforce-tab-btn">See Applicants</button>
      <button id="chat-tab-btn">Chat</button>
      <button id="proposals-tab-btn">Proposals</button>
      <button id="weapons-tab-btn">Weapon Catalogue</button>
    </div>
  </div>
  <script type="module">
  const DEBUG_LOG = false;
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
  import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';
  import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
  import { renderProposals } from './proposals.js';
  import { renderDefProposals } from './defProposals.js';


  let playerEmail = null;
  let playerMoney = 0;
  let startPosition = [70, 100, -50];

const icons = {
  health_full: 'healthfull.png',
  health_half: 'healthhalf.png',
  health_low: 'healthlow.png',
  hydration_full: 'watfull.png',
  hydration_half: 'wathalf.png',
  hydration_low: 'watlow.png',
  oxygen_full: 'o2full.png',
  oxygen_half: 'o2half.png',
  oxygen_low: 'o2low.png'
};

  function createPlaceholder(scale = 1, color = 0x5555ff) {
    const geom = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.scale.setScalar(scale);
    return mesh;
  }

  function addPointLightsFromGLTF(gltf) {
    if (!gltf || !gltf.scene) return;
    gltf.scene.traverse(node => {
      if (node.isPointLight) {
        scene.add(node);
      }
    });
  }

  const healthImg = document.getElementById('health-img');
  const hydrationImg = document.getElementById('hydration-img');
  const oxygenImg = document.getElementById('oxygen-img');
  const lowOxygenOverlay = document.getElementById('low-oxygen-overlay');
  const deathOverlay = document.getElementById('death-overlay');
  const respawnBtn = document.getElementById('respawn-btn');

  let health = 1000;
  let hydration = 1000;
  let oxygen = 1000;
  let dead = false;

  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  function fadeSwap(img, src) {
    if (img.dataset.current === src) return;
    img.style.opacity = 0;
    setTimeout(() => {
      img.src = src;
      img.dataset.current = src;
      img.style.opacity = 1;
    }, 100);
  }

function updateStatImages() {
  // Use percentage calculation with better boundaries
  const healthPct = (health / 100) * 100;  // Convert to 0-100 percentage
  const hydPct = (hydration / 100) * 100;
  const oxyPct = (oxygen / 100) * 100;

  // Health image logic
  let healthSrc = icons.health_low;
  if (healthPct >= 66) healthSrc = icons.health_full;      // 66-100%
  else if (healthPct >= 33) healthSrc = icons.health_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(healthImg, healthSrc);

  // Hydration image logic
  let hydSrc = icons.hydration_low;
  if (hydPct >= 66) hydSrc = icons.hydration_full;      // 66-100%
  else if (hydPct >= 33) hydSrc = icons.hydration_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(hydrationImg, hydSrc);

  // Oxygen image logic
  let oxySrc = icons.oxygen_low;
  if (oxyPct >= 66) oxySrc = icons.oxygen_full;      // 66-100%
  else if (oxyPct >= 33) oxySrc = icons.oxygen_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(oxygenImg, oxySrc);

  // Debug logging to help track issues
}

  function updateMoneyDisplay() {
    document.getElementById('money-display').textContent = `Money: ${playerMoney}`;
    updateInstitutionTiles();
  }

  respawnBtn.onclick = () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'respawn' }));
    }
  };

  async function autoLogin(email) {
    try {
      const res = await fetch('/api/state/' + encodeURIComponent(email));
      if (!res.ok) throw new Error('state');
      const data = await res.json();
      startPosition = data.position;
      playerMoney = data.money || 0;
      health = data.health || 1000;
      hydration = data.hydration || 1000;
      oxygen = data.oxygen || 1000;
      updateStatImages();
      playerEmail = email;
      document.getElementById('login-container').style.display = 'none';
      initNetwork();
      updateMoneyDisplay();
      return true;
    } catch {
      return false;
    }
  }

  const stored = localStorage.getItem('playerEmail');
  if (stored) {
    autoLogin(stored);
  }

    // --- Institution placement ---
  const institutions = [
    {
      name: 'WatOx',
      url: 'watox.glb',
      thumbnail: 'watox.png',
      scale: 1,
      price: 100,
      effects: { hydration: 0.5, oxygen: 0.5 },
      animated: false
    },
    {
      name: 'agriFood',
      url: 'agriFood.glb',
      thumbnail: 'https://placehold.co/100x100?text=Lab',
      scale: 1,
      price: 200,
      effects: { health: 0.2 },
      animated: true
    },
    {
      name: 'Depot',
      url: 'base.glb',
      thumbnail: 'https://placehold.co/100x100?text=Depot',
      scale: 0.5,
      price: 150,
      effects: { money: 1 },
      animated: true
    },
    {
      name: 'Defence Base',
      url: 'defba.glb',
      thumbnail: 'https://placehold.co/100x100?text=DefBase',
      scale: 10,
      price: 300,
      effects: {},
      animated: false
    }
  ];

  const institutionAudioFiles = {
    'WatOx': 'watox.mp3',
    'agriFood': 'agrifood.mp3',
    'Depot': 'depot.mp3',
    'Defence Base': 'defence_base.mp3'
  };

  const weaponAudioFiles = {
    laser: 'laser.mp3',
    bullet: 'bullet.mp3',
    missile: 'missile.mp3',
    drone: 'drone.mp3',
    kamikaze: 'kamikaze.mp3'
  };

  const panel = document.getElementById('institution-panel');
  const panelTab = panel.querySelector('.panel-tab');
  const panelContent = document.getElementById('institution-content');
  panelTab.addEventListener('click', () => {
    panel.classList.toggle('open');
  });

  const institutionTiles = [];
  const ownedInstitutions = [];
  const INSTITUTION_INTERVAL_FRAMES = 60;
  let institutionFrame = 0;
  institutions.forEach(inst => {
    const tile = document.createElement('div');
    tile.className = 'institution-tile';
    const img = document.createElement('img');
    img.src = inst.thumbnail;
    img.alt = inst.name;
    tile.appendChild(img);
    const label = document.createElement('div');
    label.textContent = `${inst.name} ($${inst.price})`;
    tile.appendChild(label);
    const overlay = document.createElement('div');
    overlay.className = 'institution-overlay';
    overlay.innerHTML = '<div>Not enough money</div><button>Request partners</button>';
    tile.appendChild(overlay);
    tile.addEventListener('click', () => {
      if (playerMoney >= inst.price) {
        selectInstitution(inst);
      }
    });
    panelContent.appendChild(tile);
    institutionTiles.push({ tile, overlay, inst });
  });

  function updateInstitutionTiles() {
    institutionTiles.forEach(t => {
      if (playerMoney >= t.inst.price) {
        t.overlay.style.display = 'none';
      } else {
        t.overlay.style.display = 'flex';
      }
    });
  }

  let ghostInstitution = null;
  let ghostMixer = null;
  let placingInstitution = false;
  let currentInstitution = null;
  let institutionPopupOpen = false;

  function selectInstitution(inst) {
    if (ghostInstitution) {
      scene.remove(ghostInstitution);
      ghostInstitution = null;
      if (ghostMixer) {
        ghostMixer.stopAllAction();
        ghostMixer = null;
      }
    }
    const loader = new GLTFLoader();
    loader.load(inst.url, gltf => {
      ghostInstitution = gltf.scene;
      addPointLightsFromGLTF(gltf);
      ghostInstitution.scale.setScalar(inst.scale || 1);
      const box = new THREE.Box3().setFromObject(ghostInstitution);
      const size = box.getSize(new THREE.Vector3());
      ghostInstitution.userData.safeDistance = Math.max(size.x, size.z) * 1.5;
      ghostInstitution.traverse(o => {
        if (o.isMesh) {
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0.5;
          o.castShadow = true;
          o.receiveShadow = true;
        }
      });
      if (inst.animated && gltf.animations && gltf.animations.length > 0) {
        ghostMixer = new THREE.AnimationMixer(ghostInstitution);
        gltf.animations.forEach(a => ghostMixer.clipAction(a).play());
      }
      scene.add(ghostInstitution);
      placingInstitution = true;
      currentInstitution = inst;
    });
  }

  function handleClick(event) {
    if (institutionPopupOpen) return;
    if (placingInstitution && ghostInstitution && currentInstitution) {
      if (playerMoney < currentInstitution.price) {
        alert('Not enough money');
        return;
      }
      const box = new THREE.Box3().setFromObject(ghostInstitution);
      const ground = getGroundHeightAt(
        ghostInstitution.position.x,
        ghostInstitution.position.z
      );
      // Flatten the terrain under the institution before placing it
      const radius = Math.max(box.max.x - box.min.x, box.max.z - box.min.z) * 0.6;
      flattenTerrain(ghostInstitution.position.x, ghostInstitution.position.z, radius, ground);
      const newGround = getGroundHeightAt(
        ghostInstitution.position.x,
        ghostInstitution.position.z
      );
      // Align the bottom of the model with the ground
      const offsetY = box.min.y - ghostInstitution.position.y;
      const targetY = newGround - offsetY;

      const data = {
        type: 'addInstitution',
        name: currentInstitution.name,
        position: [ghostInstitution.position.x, targetY, ghostInstitution.position.z],
        rotation: ghostInstitution.rotation.y,
        scale: currentInstitution.scale
      };
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(data));
      }
      scene.remove(ghostInstitution);
      ghostInstitution = null;
      if (ghostMixer) {
        ghostMixer.stopAllAction();
        ghostMixer = null;
      }
      placingInstitution = false;
      currentInstitution = null;
      return;
    }

    // Raycast to detect institution click
    const mouse = new THREE.Vector2(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1
    );
    raycaster.setFromCamera(mouse, camera);
    const objs = Object.values(institutionsMap);
    const intersects = raycaster.intersectObjects(objs, true);
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && obj.userData && obj.userData.institutionId === undefined) {
        obj = obj.parent;
      }
      if (obj && obj.userData && obj.userData.institutionId !== undefined) {
        const id = obj.userData.institutionId;
        const data = institutionDataMap[id];
        if (data && !data.destroyed) {
          showInstitutionPopup(id);
        }
        return;
      }
    }

    const wObjs = [];
    Object.values(weaponMap).forEach(arr => arr.forEach(w => { if (w && w.obj) wObjs.push(w.obj); }));
    const wHits = raycaster.intersectObjects(wObjs, true);
    if (wHits.length > 0) {
      let obj = wHits[0].object;
      while (obj && obj.userData && obj.userData.weaponInstId === undefined) {
        obj = obj.parent;
      }
      if (obj && obj.userData && obj.userData.weaponInstId !== undefined) {
        const iid = obj.userData.weaponInstId;
        const idx = obj.userData.weaponIndex;
        const w = weaponMap[iid] && weaponMap[iid][idx];
        if (w) alert('Using weapon ' + (w.data.name || '')); // placeholder
      }
    }
  }

  window.addEventListener('click', handleClick);

  function updateGhostInstitution() {
    if (!placingInstitution || !ghostInstitution || !model) return;
    const distance = ghostInstitution.userData.safeDistance || 20;
    const offset = new THREE.Vector3(0, 3, distance);
    offset.applyQuaternion(model.quaternion);
    const target = model.position.clone().add(offset);
    ghostInstitution.position.copy(target);
    ghostInstitution.rotation.y = model.rotation.y;
  }

  function getGroundHeightAt(x, z) {
    if (terrainMeshes.length === 0) return 0;
    const origin = new THREE.Vector3(x, 1000, z);
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const hits = raycaster.intersectObjects(terrainMeshes, true);
    if (hits.length > 0) {
      return hits[0].point.y;
    }
    return 0;
  }

  function flattenTerrain(x, z, radius, height) {
    const target = new THREE.Vector3();
    const inv = new THREE.Matrix4();
    terrainMeshes.forEach(mesh => {
      const geom = mesh.geometry;
      if (!geom || !geom.attributes || !geom.attributes.position) return;
      const pos = geom.attributes.position;
      inv.copy(mesh.matrixWorld).invert();
      for (let i = 0; i < pos.count; i++) {
        target.fromBufferAttribute(pos, i);
        target.applyMatrix4(mesh.matrixWorld);
        const dx = target.x - x;
        const dz = target.z - z;
        if (dx * dx + dz * dz <= radius * radius) {
          target.y = height;
          target.applyMatrix4(inv);
          pos.setXYZ(i, target.x, target.y, target.z);
        }
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();
    });
  }

  function updateStats() {
    if (dead) return;
    if (isMovingForward) {
      hydration = Math.max(hydration - 0.05, 0);
      oxygen = Math.max(oxygen - 0.02, 0);
    } else {
      hydration = Math.max(hydration - 0.02, 0);
      oxygen = Math.max(oxygen - 0.005, 0);
    }

    if (oxygen <= 10) lowOxygenOverlay.style.display = 'block';
    else lowOxygenOverlay.style.display = 'none';

    const canvas = renderer.domElement;
    if (hydration <= 20) {
      const maxBlur = 10;
      const blurAmount = maxBlur * (1 - hydration / 20);
      canvas.style.filter = `blur(${blurAmount.toFixed(1)}px)`;
    } else {
      canvas.style.filter = '';
    }

    if (oxygen <= 0 || hydration <= 0) {
      dead = true;
      deathOverlay.style.display = 'flex';
      if (dieAction) switchAnimation(dieAction);
    }

    updateStatImages();
  }

  function applyInstitutionEffects() {
    ownedInstitutions.forEach(e => {
      if (!e || typeof e !== 'object') return;
      if (typeof e.hydration === 'number') hydration = Math.min(hydration + e.hydration, 1000);
      if (typeof e.oxygen === 'number') oxygen = Math.min(oxygen + e.oxygen, 1000);
      if (typeof e.health === 'number') health = Math.min(health + e.health, 1000);
      if (typeof e.money === 'number') {
        playerMoney += e.money;
        updateMoneyDisplay();
      }
    });

    // Workforce resource consumption
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => {
          if (!w.effects) return;
          if (w.effects.hydration) hydration = Math.max(hydration + w.effects.hydration, 0);
          if (w.effects.oxygen) oxygen = Math.max(oxygen + w.effects.oxygen, 0);
          if (w.effects.health) health = Math.max(health + w.effects.health, 0);
        });
      }
    });

    // Pay workforce wages
    let wages = 0;
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => { wages += w.wage || 0; });
      }
    });
    if (wages > 0) {
      playerMoney = Math.max(playerMoney - wages, 0);
      updateMoneyDisplay();
    }
    updateStatImages();
  }

  async function startVerification(email) {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    return res.ok;
  }

  async function verifyCode(email, code) {
    const res = await fetch('/api/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, code })
    });
    if (!res.ok) throw new Error('verify');
    const data = await res.json();
    startPosition = data.user.position;
    playerMoney = data.user.money || 0;
    health = data.user.health || 1000;
    hydration = data.user.hydration || 1000;
    oxygen = data.user.oxygen || 1000;
    updateStatImages();
    playerEmail = email;
    localStorage.setItem('playerEmail', email);
    document.getElementById('login-container').style.display = 'none';
    initNetwork();
    updateMoneyDisplay();
  }

  document.getElementById('send-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    if (await startVerification(email)) {
      document.getElementById('code-section').style.display = 'block';
    }
  };

  document.getElementById('verify-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    const code = document.getElementById('login-code').value;
    try {
      await verifyCode(email, code);
    } catch (e) {
      document.getElementById('login-error').textContent = 'Verification failed';
    }
  };

  // Scene, camera, renderer
  const scene = new THREE.Scene();
  const marsSkyColor = 0x9B7653; // Dusty orange-red for Mars sky
  // Mild atmospheric haze
  scene.fog = new THREE.FogExp2(marsSkyColor, 0.002);

  // Adjusted camera far plane for potentially larger terrain
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 10, 15);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Better shadows
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(marsSkyColor);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // --- Audio setup ---
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const audioLoader = new THREE.AudioLoader();

  // Post-processing setup for bloom
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // Ambient occlusion pass for subtle shading
  const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
  ssaoPass.kernelRadius = 8;
  ssaoPass.minDistance = 0.005;
  ssaoPass.maxDistance = 0.1;
  composer.addPass(ssaoPass);

  // Bloom effect
  const bloomParams = {
    strength: 0.1,
    radius: 0.7,
    threshold: 0.8
  };
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    bloomParams.strength,
    bloomParams.radius,
    bloomParams.threshold
  );
  composer.addPass(bloomPass);

  // Output pass to properly handle tone mapping
  const outputPass = new OutputPass();
  composer.addPass(outputPass);

  // --- Multiplayer Networking ---
  let socket;
  let clientId = null;
  const remotePlayers = {};
  const pendingRemotePlayers = [];
  const institutionsMap = {};
  const institutionMixers = {};
  const institutionDataMap = {};
  const institutionBoxes = [];
  const constructionBoxes = [];
  const sinking = [];
  const constructionMap = {}; // id -> array of {scaff, final}
  const weaponMap = {}; // id -> array of weapon objects
  const projectiles = []; // active fired weapon objects
  const institutionSounds = {}; // id -> THREE.PositionalAudio
  const weaponSounds = {}; // instId -> array of sounds
  const weaponMixers = {}; // instId -> array of AnimationMixers
  let footstepSound = null;
  const flagObjects = {}; // player id -> flag object
  let currentFlagPos = null;

  function initNetwork() {
    socket = new WebSocket('ws://localhost:3000?email=' + encodeURIComponent(playerEmail));
    socket.addEventListener('message', e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'welcome') {
        clientId = msg.id;
        msg.players.forEach(p => {
          if (p.flag) createFlag(p.id, p.flag);
          if (p.id !== clientId) createRemotePlayer(p.id, p);
        });
        if (msg.institutions) {
          msg.institutions.forEach(i => createInstitution(i, false));
        }
        if (typeof msg.money === 'number') {
          playerMoney = msg.money;
          updateMoneyDisplay();
        }
        if (typeof msg.health === 'number') health = msg.health;
        if (typeof msg.hydration === 'number') hydration = msg.hydration;
        if (typeof msg.oxygen === 'number') oxygen = msg.oxygen;
        updateStatImages();
      } else if (msg.type === 'spawn') {
        if (msg.state && msg.state.flag) createFlag(msg.id, msg.state.flag);
        createRemotePlayer(msg.id, msg.state);
      } else if (msg.type === 'update') {
        if (msg.id !== clientId) updateRemotePlayer(msg.id, msg);
      } else if (msg.type === 'remove') {
        removeRemotePlayer(msg.id);
      } else if (msg.type === 'addInstitution') {
        createInstitution(msg.institution, true);
      } else if (msg.type === 'updateInstitution') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          inst.extraEffects = msg.extraEffects || inst.extraEffects || {};
          if (msg.construction !== undefined) {
            if (!Array.isArray(inst.constructions)) inst.constructions = [];
            inst.constructions[msg.index] = msg.construction;
            applyConstruction(inst);
          }
          if (
            inst.owner === playerEmail &&
            msg.gains &&
            typeof msg.gains === 'object' &&
            !Array.isArray(msg.gains)
          ) {
            ownedInstitutions.push(msg.gains);
          }
        }
      } else if (msg.type === 'updateWeapon') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          if (!Array.isArray(inst.weapons)) inst.weapons = [];
          inst.weapons[msg.index] = msg.weapon;
          applyWeapons(inst);
        }
      } else if (msg.type === 'destroyInstitution') {
        handleInstitutionDestruction(msg.id);
      } else if (msg.type === 'money') {
        playerMoney = msg.money;
        updateMoneyDisplay();
      } else if (msg.type === 'flag') {
        createFlag(msg.id, msg.position);
      } else if (msg.type === 'respawn') {
  dead = false;
  deathOverlay.style.display = 'none';

  // Set values
  oxygen = msg.oxygen;
  hydration = msg.hydration;
  health = msg.health;
  playerMoney = msg.money;

  // Clear effects
  renderer.domElement.style.filter = '';
  lowOxygenOverlay.style.display = 'none';

  // FORCE RESET IMAGES - DIRECT APPROACH
  healthImg.dataset.current = '';  // Clear cache
  hydrationImg.dataset.current = '';
  oxygenImg.dataset.current = '';

  // DIRECTLY SET TO FULL IMAGES
  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  updateMoneyDisplay();
  if (idleAction) switchAnimation(idleAction);
}
    });
  }

  function createRemotePlayer(id, state) {
    if (!model) {
      pendingRemotePlayers.push({ id, state });
      return;
    }
    if (remotePlayers[id]) return;
    const remote = SkeletonUtils.clone(model);
    scene.add(remote);
    const m = new THREE.AnimationMixer(remote);
    let idle, walk, run, die;
    if (playerAnimations) {
      const idleClip = playerAnimations.find(a => a.name.toLowerCase() === 'idle');
      const walkClip = playerAnimations.find(a => a.name.toLowerCase() === 'walk');
      const runClip = playerAnimations.find(a => a.name.toLowerCase() === 'run');
      const dieClip = playerAnimations.find(a => a.name.toLowerCase() === 'die');
      if (idleClip) idle = m.clipAction(idleClip);
      if (walkClip) walk = m.clipAction(walkClip);
      if (runClip) run = m.clipAction(runClip);
      if (dieClip) {
        die = m.clipAction(dieClip);
        die.setLoop(THREE.LoopOnce, 1);
        die.clampWhenFinished = true;
      }
    }
    if (idle) idle.play();
    remotePlayers[id] = { model: remote, mixer: m, idle, walk, run, die, active: idle };
    if (state) {
      remote.position.fromArray(state.position);
      remote.rotation.y = state.rotation;
    }
  }

  function updateRemotePlayer(id, state) {
    const rp = remotePlayers[id];
    if (!rp) return;
    rp.model.position.fromArray(state.position);
    rp.model.rotation.y = state.rotation;
    let target = rp.idle;
    if (state.oxygen <= 0 || state.hydration <= 0) {
      target = rp.die || target;
    } else if (typeof state.moving === 'boolean') {
      if (state.moving) {
        target = state.running ? rp.run : (rp.walk || rp.run);
      } else {
        target = rp.idle;
      }
    }
    if (target && rp.active !== target) {
      rp.active && rp.active.fadeOut(0.2);
      target.reset().fadeIn(0.2).play();
      rp.active = target;
    }
  }

  function removeRemotePlayer(id) {
    const rp = remotePlayers[id];
    if (!rp) return;
    scene.remove(rp.model);
    delete remotePlayers[id];
  }

  function removeConstructionBoxes(id) {
    for (let i = constructionBoxes.length - 1; i >= 0; i--) {
      if (constructionBoxes[i].id === id) constructionBoxes.splice(i, 1);
    }
  }

  function applyConstruction(inst) {
    const existing = constructionMap[inst.id] || [];
    existing.forEach(e => {
      if (e.scaff) scene.remove(e.scaff);
      if (e.final) scene.remove(e.final);
    });
    removeConstructionBoxes(inst.id);
    constructionMap[inst.id] = [];
    if (!Array.isArray(inst.constructions)) return;
    inst.constructions.forEach((c, idx) => {
      if (!c) return;
      const loader = new GLTFLoader();
      loader.load(c.url, gltf => {
        if (inst.constructions[idx] !== c) return; // ignore outdated load
        const obj = gltf.scene;
        addPointLightsFromGLTF(gltf);
        const offset = Array.isArray(c.offset)
          ? new THREE.Vector3().fromArray(c.offset)
          : null;
        let pos = new THREE.Vector3().fromArray(inst.position);
        if (offset) {
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
          pos.add(offset);
        } else {
          const boxEntry = institutionBoxes.find(b => b.id === inst.id);
          if (boxEntry) {
            const size = new THREE.Vector3();
            boxEntry.box.getSize(size);
            const off = new THREE.Vector3(size.x / 2 + 5, 0, 0);
            off.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
            pos.add(off);
          } else {
            pos.x += 5;
          }
        }

        obj.scale.setScalar(c.scale || inst.scale || 1);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        const boxTmp = new THREE.Box3().setFromObject(obj);
        const radius = Math.max(boxTmp.max.x - boxTmp.min.x, boxTmp.max.z - boxTmp.min.z) * 0.6;
        const ground = getGroundHeightAt(pos.x, pos.z);
        flattenTerrain(pos.x, pos.z, radius, ground);
        obj.position.set(pos.x, ground - boxTmp.min.y, pos.z);

        const cbox = new THREE.Box3().setFromObject(obj);
        constructionBoxes.push({ id: inst.id, index: idx, box: cbox });

        if (!constructionMap[inst.id][idx]) constructionMap[inst.id][idx] = {};
        if (c.status === 'scaffolding') {
          constructionMap[inst.id][idx].scaff = obj;
        } else {
          constructionMap[inst.id][idx].final = obj;
        }
      }, undefined, () => {
        if (inst.constructions[idx] !== c) return;
        const obj = createPlaceholder(c.scale || inst.scale || 1, 0x888888);
        const offset = Array.isArray(c.offset)
          ? new THREE.Vector3().fromArray(c.offset)
          : null;
        let pos = new THREE.Vector3().fromArray(inst.position);
        if (offset) {
          offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
          pos.add(offset);
        } else {
          const boxEntry = institutionBoxes.find(b => b.id === inst.id);
          if (boxEntry) {
            const size = new THREE.Vector3();
            boxEntry.box.getSize(size);
            const off = new THREE.Vector3(size.x / 2 + 5, 0, 0);
            off.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
            pos.add(off);
          } else {
            pos.x += 5;
          }
        }
        obj.position.copy(pos);
        scene.add(obj);
        const cbox = new THREE.Box3().setFromObject(obj);
        constructionBoxes.push({ id: inst.id, index: idx, box: cbox });
        if (!constructionMap[inst.id][idx]) constructionMap[inst.id][idx] = {};
        if (c.status === 'scaffolding') {
          constructionMap[inst.id][idx].scaff = obj;
        } else {
          constructionMap[inst.id][idx].final = obj;
        }
      });
    });
  }

  function createFlag(id, position) {
    if (!position || position.length < 3) return;
    const pos = Array.isArray(position) ? new THREE.Vector3().fromArray(position) : position.clone();
    let existing = flagObjects[id];
    if (existing) scene.remove(existing);
    const loader = new GLTFLoader();
    loader.load('flag.glb', gltf => {
      const obj = gltf.scene;
      obj.position.copy(pos);
      scene.add(obj);
      flagObjects[id] = obj;
      if (id === clientId) currentFlagPos = obj.position;
    }, undefined, () => {
      const obj = createPlaceholder(0.5, 0xff0000);
      obj.position.copy(pos);
      scene.add(obj);
      flagObjects[id] = obj;
      if (id === clientId) currentFlagPos = obj.position;
    });
  }

  function plantFlag() {
    if (!model) return;
    const offset = new THREE.Vector3(0, 0, -5).applyQuaternion(model.quaternion);
    const pos = model.position.clone().add(offset);
    const y = getGroundHeightAt(pos.x, pos.z);
    pos.y = y;
    createFlag(clientId, [pos.x, pos.y, pos.z]);
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'target', position: [pos.x, pos.y, pos.z] }));
    }
    if (flagPlantAction) switchAnimation(flagPlantAction);
  }

  function applyWeapons(inst) {
    const existing = weaponMap[inst.id] || [];
    existing.forEach(w => { if (w.obj) scene.remove(w.obj); });
    const mixArr = weaponMixers[inst.id] || [];
    mixArr.forEach(m => { if (m) { m.stopAllAction(); } });
    weaponMixers[inst.id] = [];
    weaponMap[inst.id] = [];
    if (!Array.isArray(inst.weapons)) return;
    inst.weapons.forEach((w, idx) => {
      if (!w) return;
      const offset = Array.isArray(w.offset)
        ? new THREE.Vector3().fromArray(w.offset)
        : new THREE.Vector3(6 + idx * 2, 0, 0);
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
      const pos = new THREE.Vector3().fromArray(inst.position).add(offset);

      if (!w.model) {
        const obj = createPlaceholder(w.scale || 1, 0xff0000);
        obj.position.copy(pos);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };
        return;
      }

      const loader = new GLTFLoader();
      loader.load(w.model, gltf => {
        if (inst.weapons[idx] !== w) return; // ignore outdated load
        const obj = gltf.scene;
        addPointLightsFromGLTF(gltf);
      obj.scale.setScalar(w.scale || 1);
      obj.rotation.y = inst.rotation || 0;
      scene.add(obj);
      if (gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        gltf.animations.forEach(anim => mix.clipAction(anim).play());
        if (!weaponMixers[inst.id]) weaponMixers[inst.id] = [];
        weaponMixers[inst.id][idx] = mix;
      }

      let techKey = w.technology;
      if (Array.isArray(techKey)) techKey = techKey[0];
      if (techKey && typeof techKey === 'object') {
        const keys = Object.keys(techKey);
        techKey = keys.length ? keys[0] : '';
      }
      const techFile = weaponAudioFiles[(typeof techKey === 'string' ? techKey : '').toLowerCase()];
      if (techFile) {
        const wsound = new THREE.PositionalAudio(listener);
        audioLoader.load(techFile, buffer => {
          wsound.setBuffer(buffer);
          wsound.setLoop(true);
          wsound.setRefDistance(15);
          wsound.setVolume(1);
          wsound.play();
        });
        obj.add(wsound);
        if (!weaponSounds[inst.id]) weaponSounds[inst.id] = [];
        weaponSounds[inst.id][idx] = wsound;
      }

      const boxTmp = new THREE.Box3().setFromObject(obj);
        const radius = Math.max(boxTmp.max.x - boxTmp.min.x, boxTmp.max.z - boxTmp.min.z) * 0.6;
        const ground = getGroundHeightAt(pos.x, pos.z);
        flattenTerrain(pos.x, pos.z, radius, ground);
        obj.position.set(pos.x, ground - boxTmp.min.y, pos.z);
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };

        // Debug: log weapon placement when the generated model is loaded
        if (DEBUG_LOG) {
          console.log('[DEBUG] Weapon model loaded', {
            institution: inst.id,
            index: idx,
            position: {
              x: obj.position.x,
              y: obj.position.y,
              z: obj.position.z
            }
          });
        }
      }, undefined, () => {
        if (inst.weapons[idx] !== w) return;
        const obj = createPlaceholder(w.scale || 1, 0xff0000);
        obj.position.copy(pos);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        obj.traverse(o => {
          o.userData.weaponInstId = inst.id;
          o.userData.weaponIndex = idx;
        });
        weaponMap[inst.id][idx] = { obj, data: w };
      });
    });
  }

  function fireWeapon(entry) {
    if (!model || !entry || !entry.obj || !entry.data) return;
    const params = entry.data.parameters || {};
    let tech = entry.data.technology;
    if (Array.isArray(tech)) tech = tech[0];
    if (tech && typeof tech === 'object') {
      const keys = Object.keys(tech);
      tech = keys.length ? keys[0] : '';
    }
    tech = (typeof tech === 'string' ? tech : '').toLowerCase();
    const cat = (entry.data.category || '').toLowerCase();
    const start = entry.obj.position.clone();
    const target = currentFlagPos ? currentFlagPos.clone() : model.position.clone();
    const clone = SkeletonUtils.clone(entry.obj);
    clone.position.copy(start);
    scene.add(clone);
    projectiles.push({ obj: clone, tech, cat, params, start, target, stage: 0, speed: 0 });

    // Debug: log weapon firing start information
    if (DEBUG_LOG) {
      console.log('[DEBUG] Fire weapon', {
        weaponTech: tech,
        weaponCategory: cat,
        params,
        characterPosition: {
          x: target.x,
          y: target.y,
          z: target.z
        },
        startPosition: {
          x: start.x,
          y: start.y,
          z: start.z
        },
        animation: activeAction && activeAction._clip ? activeAction._clip.name : 'none'
      });
    }
  }

  function fireAllWeapons() {
    Object.values(weaponMap).forEach(arr => arr.forEach(w => fireWeapon(w)));
  }

  function updateProjectiles(dt) {
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      const weight = p.params.weight || 1;
      const force = p.params.force || 0;
      const ammo = p.params.ammo || 0;
      const fuel = p.params.fuel || 0;
      if (p.cat !== 'attack') {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
        continue;
      }
      // check collision with institutions
      const sphere = new THREE.Sphere(p.obj.position.clone(), 20);
      let hitInst = null;
      for (const entry of institutionBoxes) {
        const data = institutionDataMap[entry.id];
        if (!data || data.destroyed) continue;
        if (entry.box.intersectsSphere(sphere)) {
          hitInst = entry.id;
          break;
        }
      }
      if (hitInst !== null) {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
        sendDestroyInstitution(hitInst);
        continue;
      }
      if (p.tech === 'laser') {
        if (!p.dir) {
          p.dir = new THREE.Vector3().subVectors(p.target, p.start).normalize();
          p.speed = force * 1;
        }
        const step = p.speed * dt;
        p.obj.position.addScaledVector(p.dir, step);
        if (p.obj.position.distanceTo(p.target) <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else if (p.tech === 'bullet') {
        if (!p.dir) {
          p.dir = new THREE.Vector3().subVectors(p.target, p.start).normalize();
          p.speed = weight > 0 ? (force / weight) : force;
        }
        const step = p.speed * dt;
        p.obj.position.addScaledVector(p.dir, step);
        if (p.obj.position.distanceTo(p.target) <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else if (p.tech === 'missile') {
        if (p.stage === 0) {
          p.h = p.h || (force * fuel / (weight + ammo + fuel)) * 10;
          p.v0 = p.v0 || (force / weight);
          p.v1 = p.v1 || (weight * p.h);
          p.speed = p.v0;
          const targetY = p.start.y + p.h;
          p.obj.position.y += p.v0 * dt;
          if (p.obj.position.y >= targetY) {
            p.stage = 1;
            p.dir = new THREE.Vector3().subVectors(p.target, p.obj.position).normalize();
          }
        } else {
          p.speed += (p.v1 - p.speed) * 0.05;
          const step = p.speed * dt;
          p.obj.position.addScaledVector(p.dir, step);
          if (p.obj.position.distanceTo(p.target) <= step) {
            scene.remove(p.obj);
            projectiles.splice(i, 1);
          }
        }
      } else if (p.tech === 'drone') {
        p.h = p.h || (force / weight) * 10;
        p.v0 = p.v0 || (force / weight);
        p.v1 = p.v1 || (weight * p.h);
        if (p.stage === 0) {
          const targetY = p.start.y + p.h;
          p.obj.position.y += p.v0 * dt;
          if (p.obj.position.y >= targetY) {
            p.stage = 1;
          }
        } else if (p.stage === 1) {
          if (!p.dir) p.dir = new THREE.Vector3(p.target.x - p.obj.position.x, 0, p.target.z - p.obj.position.z).normalize();
          p.speed += (p.v1 - (p.speed || p.v0)) * 0.05;
          const step = p.speed * dt;
          const move = p.dir.clone().multiplyScalar(step);
          p.obj.position.add(move);
          if (new THREE.Vector2(p.obj.position.x - p.target.x, p.obj.position.z - p.target.z).length() <= step) {
            p.stage = 2;
            p.dir = new THREE.Vector3(0, -1, 0);
          }
        } else {
          const step = p.v1 * dt;
          p.obj.position.addScaledVector(p.dir, step);
          if (p.obj.position.y <= p.target.y) {
            p.obj.position.copy(p.target);
            scene.remove(p.obj);
            projectiles.splice(i, 1);
          }
        }
      } else if (p.tech === 'kamikaze') {
        if (!p.dir) p.dir = new THREE.Vector2(p.target.x - p.start.x, p.target.z - p.start.z).normalize();
        p.speed = p.speed || ((force * fuel) / weight);
        const step = p.speed * dt;
        p.obj.position.x += p.dir.x * step;
        p.obj.position.z += p.dir.y * step;
        p.obj.position.y = getGroundHeightAt(p.obj.position.x, p.obj.position.z);
        if (new THREE.Vector2(p.obj.position.x - p.target.x, p.obj.position.z - p.target.z).length() <= step) {
          scene.remove(p.obj);
          projectiles.splice(i, 1);
        }
      } else {
        scene.remove(p.obj);
        projectiles.splice(i, 1);
      }
    }
  }

  function handleInstitutionDestruction(id) {
    const obj = institutionsMap[id];
    const data = institutionDataMap[id];
    if (!obj || !data || data.destroyed) return;
    data.destroyed = true;
    data.workforce = [];
    data.proposals = [];
    data.proposalHistory = [];
    data.constructions = [];
    const anims = obj.userData.animations || [];
    if (anims.length > 0) {
      const clip = anims.find(a => a.name === 'destruction') || anims[0];
      const mix = new THREE.AnimationMixer(obj);
      const action = mix.clipAction(clip);
      action.setLoop(THREE.LoopOnce, 0);
      action.clampWhenFinished = true;
      action.play();
      action.onFinished = () => {
        action.paused = true;
        action.time = clip.duration;
        mix.update(0);
      };
      institutionMixers[id] = mix;
    }
  }

  function createInstitution(inst, animate) {
    const def = institutions.find(i => i.name === inst.name);
    if (!def) return;
    const loader = new GLTFLoader();
    loader.load(def.url, gltf => {
      const obj = gltf.scene;
      obj.userData.animations = gltf.animations || [];
      addPointLightsFromGLTF(gltf);
      obj.scale.setScalar(inst.scale || def.scale || 1);
      obj.position.fromArray(inst.position);
      obj.rotation.y = inst.rotation || 0;
      obj.traverse(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
        }
      });
      const boxTmp = new THREE.Box3().setFromObject(obj);
      const radius = Math.max(boxTmp.max.x - boxTmp.min.x, boxTmp.max.z - boxTmp.min.z) * 0.6;
      const ground = getGroundHeightAt(inst.position[0], inst.position[2]);
      flattenTerrain(inst.position[0], inst.position[2], radius, ground);
      scene.add(obj);

      const instAudioFile = institutionAudioFiles[inst.name];
      if (instAudioFile) {
        const sound = new THREE.PositionalAudio(listener);
       audioLoader.load(instAudioFile, buffer => {
      sound.setLoop(true);
      sound.setRefDistance(1);
      sound.setRolloffFactor(10.0);
      sound.setMaxDistance(10);
      sound.setVolume(1);
      sound.setBuffer(buffer);
      if (sound.isPlaying) sound.stop();
      sound.play();
    });

        obj.add(sound);
        institutionSounds[inst.id] = sound;
      }

      if (inst.destroyed && gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        const clip = gltf.animations.find(a => a.name === 'destruction') || gltf.animations[0];
        const action = mix.clipAction(clip);
        action.play();
        action.paused = true;
        action.time = clip.duration;
        mix.update(0);
      } else if (def.animated && gltf.animations && gltf.animations.length > 0) {
        const mix = new THREE.AnimationMixer(obj);
        gltf.animations.forEach(anim => {
          mix.clipAction(anim).play();
        });
        institutionMixers[inst.id] = mix;
      }
      institutionsMap[inst.id] = obj;
      const cons = inst.constructions || (inst.construction ? [inst.construction] : []);
      institutionDataMap[inst.id] = { ...inst, effects: def.effects, workforce: inst.workforce || [], extraEffects: inst.extraEffects || {}, constructions: cons };
      obj.traverse(o => { o.userData.institutionId = inst.id; });
      const box = new THREE.Box3().setFromObject(obj);
      institutionBoxes.push({ id: inst.id, box });
      if (!inst.destroyed) {
        applyConstruction(institutionDataMap[inst.id]);
        applyWeapons(institutionDataMap[inst.id]);
      }
      if (inst.owner === playerEmail && !inst.destroyed) {
        if (def.effects) ownedInstitutions.push(def.effects);
        if (inst.extraEffects) ownedInstitutions.push(inst.extraEffects);
      }
      if (animate) {
        const startY = obj.position.y + 5;
        const endY = obj.position.y;
        obj.position.y = startY;
        sinking.push({ obj, start: startY, end: endY, t: 0, emit: 0 });
      }
    }, undefined, () => {
      const obj = createPlaceholder(inst.scale || def.scale || 1, 0x00aa00);
      obj.userData.animations = [];
      obj.position.fromArray(inst.position);
      obj.rotation.y = inst.rotation || 0;
      scene.add(obj);
      obj.traverse(o => { o.userData.institutionId = inst.id; });
      institutionsMap[inst.id] = obj;
      const box = new THREE.Box3().setFromObject(obj);
      institutionBoxes.push({ id: inst.id, box });
      institutionDataMap[inst.id] = { ...inst, effects: def.effects, workforce: inst.workforce || [], extraEffects: inst.extraEffects || {}, constructions: inst.constructions || [] };
      if (!inst.destroyed) {
        applyConstruction(institutionDataMap[inst.id]);
        applyWeapons(institutionDataMap[inst.id]);
      }
    });
  }

  function showInstitutionPopup(id) {
    const popup = document.getElementById('institution-popup');
    const infoTabBtn = document.getElementById('info-tab-btn');
    const workforceTabBtn = document.getElementById('workforce-tab-btn');
    const chatTabBtn = document.getElementById('chat-tab-btn');
    const proposalsTabBtn = document.getElementById('proposals-tab-btn');
    const weaponsTabBtn = document.getElementById('weapons-tab-btn');
    const infoDiv = document.getElementById('popup-info');
    const workforceDiv = document.getElementById('popup-workforce');
    const chatDiv = document.getElementById('popup-chat');
    const proposalsDiv = document.getElementById('popup-proposals');
    const weaponsDiv = document.getElementById('popup-weapons');
    const chatContainer = document.getElementById('chat-container');
    const ownerSpan = document.getElementById('popup-owner');
    const resDiv = document.getElementById('popup-resources');
    const closeBtn = document.getElementById('popup-close');

    let chatInterval = null;

    const instData = institutionDataMap[id];
    if (!instData || instData.destroyed) return;
    const isOwner = instData.owner === playerEmail;
    const def = institutions.find(i => i.name === instData.name);
    let count = 0;
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === instData.owner && d.name === instData.name) count++;
    });
    const effects = Object.assign({}, def.effects || {});
    if (instData.extraEffects) {
      for (const k of Object.keys(instData.extraEffects)) {
        const val = instData.extraEffects[k];
        if (typeof val === 'number' && isFinite(val)) {
          effects[k] = (effects[k] || 0) + val;
        }
      }
    }
    const lines = [];
    Object.keys(effects).forEach(k => {
      if (typeof effects[k] === 'number' && isFinite(effects[k])) {
        lines.push(`${k}: +${effects[k]} (${(effects[k] * count).toFixed(2)} total)`);
      }
    });
    resDiv.textContent = lines.join(' | ');
    const actionsDiv = popup.querySelector('.popup-actions');
    if (isOwner) {
      actionsDiv.style.display = 'flex';
      resDiv.style.display = 'block';
      ownerSpan.innerHTML = `Owner: <span id="owner-click" style="text-decoration:underline;cursor:pointer;">${instData.owner}</span>`;
    } else {
      actionsDiv.style.display = 'none';
      resDiv.style.display = 'none';
      ownerSpan.textContent = `Owner: ${instData.owner}`;
    }

    function showInfo() {
      infoDiv.style.display = 'block';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'none';
      weaponsDiv.style.display = 'none';
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      const carousel = document.getElementById('popup-workforce-carousel');
      carousel.innerHTML = '';
      const workers = [];
      Object.values(institutionDataMap).forEach(d => {
        if (d.owner === instData.owner && d.name === instData.name && Array.isArray(d.workforce)) {
          workers.push(...d.workforce);
        }
      });
      if (workers.length === 0) {
        carousel.textContent = 'No workforce';
        return;
      }
      workers.forEach(w => {
        const item = document.createElement('div');
        item.style.minWidth = '80px';
        item.style.display = 'flex';
        item.style.flexDirection = 'column';
        item.style.alignItems = 'center';
        const img = document.createElement('img');
        img.src = w.image;
        img.style.width = '60px';
        img.style.height = '80px';
        item.appendChild(img);
        const name = document.createElement('div');
        name.textContent = w.name + (w.director ? ' \u2605' : '');
        name.style.fontSize = '12px';
        item.appendChild(name);
        carousel.appendChild(item);
      });
    }

    async function showWorkforce() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'block';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'none';
      weaponsDiv.style.display = 'none';
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      const container = document.getElementById('workforce-container');
      // Immediately show loading spinner
      container.innerHTML = '<div class="spinner" style="display: flex; justify-content: center; align-items: center; height: 200px; color: #fff;">Loading applicants...</div>';

      try {
        const res = await fetch(`/api/workforce/generate/${id}`, { method: 'POST' });
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const workersData = await res.json();

        // Clear loading and display workers
        container.innerHTML = '';

        if (!workersData.workers || workersData.workers.length === 0) {
          container.innerHTML = '<div style="color: #fff; text-align: center;">No applicants available</div>';
          return;
        }

        workersData.workers.forEach(w => {
          const card = document.createElement('div');
          card.className = 'worker-card';
          card.style.width = '150px';
          card.style.perspective = '800px';
          const inner = document.createElement('div');
          inner.className = 'card-inner';
          inner.style.position = 'relative';
          inner.style.width = '100%';
          inner.style.height = '200px';
          inner.style.transition = 'transform 0.6s';
          inner.style.transformStyle = 'preserve-3d';
          const front = document.createElement('div');
          front.style.position = 'absolute';
          front.style.backfaceVisibility = 'hidden';
          front.style.width = '100%';
          front.style.height = '100%';
          front.style.backgroundImage = `url(${w.image})`;
          front.style.backgroundSize = 'cover';
          front.style.backgroundPosition = 'center';
          front.textContent = w.name + (w.director ? ' \u2605' : '');
          front.style.display = 'flex';
          front.style.alignItems = 'flex-end';
          front.style.justifyContent = 'center';
          front.style.color = '#fff';
          front.style.textShadow = '0 1px 3px rgba(0,0,0,0.8)';
          front.style.padding = '8px';
          front.style.textAlign = 'center';
          front.style.fontSize = '14px';
          front.style.fontWeight = 'bold';
          const back = document.createElement('div');
          back.style.position = 'absolute';
          back.style.transform = 'rotateY(180deg)';
          back.style.backfaceVisibility = 'hidden';
          back.style.width = '100%';
          back.style.height = '100%';
          back.style.background = '#333';
          back.style.color = '#fff';
          back.style.fontSize = '12px';
          back.style.padding = '8px';
          back.style.overflowY = 'auto';
          back.style.boxSizing = 'border-box';
          back.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>${w.role}${w.director ? ' \u2605' : ''}</strong></div>
            <div style="margin-bottom: 8px; font-size: 11px;">${w.backstory}</div>
            <div style="margin-bottom: 8px; font-size: 11px;">${w.resume}</div>
            <div style="font-weight: bold;">Wage: $${w.wage}/day</div>
          `;
          inner.appendChild(front);
          inner.appendChild(back);
          card.appendChild(inner);
          card.onclick = () => {
            inner.style.transform = inner.style.transform === 'rotateY(180deg)' ? '' : 'rotateY(180deg)';
          };
          const hireBtn = document.createElement('button');
          hireBtn.textContent = 'Hire';
          hireBtn.style.width = '100%';
          hireBtn.style.marginTop = '20px';
          hireBtn.onclick = async (e) => {
            e.stopPropagation();
            try {
              const hireRes = await fetch(`/api/workforce/hire/${id}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ worker: w })
              });
              if (hireRes.ok) {
                if (!instData.workforce) instData.workforce = [];
                instData.workforce.push(w);
                container.removeChild(card);
                if (container.children.length === 0) {
                  container.innerHTML = '<div style="color: #fff; text-align: center;">All applicants hired!</div>';
                }
              } else {
                alert('Failed to hire worker');
              }
            } catch (err) {
              alert('Failed to hire worker');
            }
          };
          card.appendChild(hireBtn);
          container.appendChild(card);
        });
      } catch (err) {
        container.innerHTML = '<div style="color: #ff6666; text-align: center;">Failed to load applicants. Please try again.</div>';
      }
    }

    async function showChat() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'block';
      proposalsDiv.style.display = 'none';
      weaponsDiv.style.display = 'none';
      if (chatInterval) clearInterval(chatInterval);
      const input = document.getElementById('chat-input');
      const sendBtn = document.getElementById('chat-send');
      let lastHeight = 0;
      async function load() {
        try {
          const res = await fetch(`/api/workforce/chat/${id}`);
          if (res.ok) {
            const data = await res.json();
            chatContainer.innerHTML = '';
            data.messages.forEach(m => {
              const box = document.createElement('div');
              box.className = 'chat-msg';
              let text = m.text;
              if (typeof m.text === 'object' && m.text !== null) {
                text = m.text.dialogue || '';
                if (m.text.is_proposal && m.text.proposal) {
                  const p = m.text.proposal;
                  const parts = [];
                  if (p.title) parts.push(`Title: ${p.title}`);
                  if (p.description) parts.push(`Description: ${p.description}`);
                  if (p.cost !== undefined) parts.push(`Cost: $${p.cost}`);
                  const info = parts.join(' | ');
                  if (info) text += ` (Proposal - ${info})`;
                }
              }
              box.textContent = `${m.worker}: ${text}`;
              chatContainer.appendChild(box);
              if (typeof m.text === 'object' && m.text !== null && m.text.raw) {
                const preRaw = document.createElement('pre');
                preRaw.className = 'chat-raw';
                preRaw.textContent = m.text.raw;
                chatContainer.appendChild(preRaw);
                if (m.text.proposal) {
                  const preObj = document.createElement('pre');
                  preObj.className = 'chat-raw';
                  preObj.textContent = JSON.stringify(m.text.proposal, null, 2);
                  chatContainer.appendChild(preObj);
                }
              }
            });
            if (chatContainer.scrollHeight !== lastHeight) {
              chatContainer.scrollTop = chatContainer.scrollHeight;
              lastHeight = chatContainer.scrollHeight;
            }
          }
        } catch (err) {
        }
      }
      await load();
      chatInterval = setInterval(load, 5000);

      async function send() {
        const text = input.value.trim();
        if (!text) return;
        input.value = '';
        await fetch(`/api/workforce/chat/${id}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        await load();
      }

      sendBtn.onclick = send;
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') send();
      });
    }

    async function showProposals() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'block';
      weaponsDiv.style.display = 'none';
      if (chatInterval) { clearInterval(chatInterval); chatInterval = null; }
      const container = document.getElementById('proposals-container');
      container.innerHTML = '<div class="spinner" style="height:100px;color:#fff">Loading...</div>';
      if (DEBUG_LOG) console.log('[DEFENCE UI] showProposals', { instId: id });
      try {
        if (instData.name === 'Defence Base') {
          const res = await fetch(`/api/defence/proposals/${id}`);
          if (res.ok) {
            const data = await res.json();
            renderDefProposals(container, data.proposals || [], id);
          }
        } else {
          const res = await fetch(`/api/workforce/proposals/${id}`);
          const hist = await fetch(`/api/workforce/proposals/history/${id}`);
          if (res.ok && hist.ok) {
            const data = await res.json();
            const h = await hist.json();
            renderProposals(container, data.proposals || [], id, institutionDataMap, playerEmail, ownedInstitutions, h.history || []);
          }
        }
      } catch(err){
        container.innerHTML = '<div style="color:#ff6666">Failed</div>';
      }
    }

    async function showWeapons() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'none';
      weaponsDiv.style.display = 'block';
      if (chatInterval) { clearInterval(chatInterval); chatInterval = null; }
      const container = document.getElementById('weapons-container');
      container.innerHTML = '<div class="spinner" style="height:100px;color:#fff">Loading...</div>';
      try {
        const res = await fetch(`/api/defence/weapons/${id}`);
        if (res.ok) {
          const data = await res.json();
          container.innerHTML = '';
          (data.weapons || []).forEach(w => {
            const div = document.createElement('div');
            div.textContent = `${w.name} - movement ${w.movement.toFixed(2)}`;
            div.className = 'weapon-entry';
            div.onclick = () => alert('Using weapon ' + w.name);
            container.appendChild(div);
          });
          if (!data.weapons || data.weapons.length === 0) {
            container.textContent = 'No weapons';
          }
        }
      } catch {
        container.innerHTML = '<div style="color:#ff6666">Failed</div>';
      }
    }

    if (isOwner) {
      infoTabBtn.onclick = showInfo;
      workforceTabBtn.onclick = showWorkforce;
      chatTabBtn.onclick = showChat;
      proposalsTabBtn.onclick = showProposals;
      if (instData.name === 'Defence Base') {
        weaponsTabBtn.style.display = 'inline-block';
        weaponsTabBtn.onclick = showWeapons;
      } else {
        weaponsTabBtn.style.display = 'none';
        weaponsTabBtn.onclick = null;
      }
    } else {
      infoTabBtn.onclick = null;
      workforceTabBtn.onclick = null;
      chatTabBtn.onclick = null;
      proposalsTabBtn.onclick = null;
      weaponsTabBtn.onclick = null;
      weaponsTabBtn.style.display = 'none';
    }

   function closePopup() {
     popup.style.display = 'none';
     institutionPopupOpen = false;
     document.removeEventListener('keydown', escHandler);
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      proposalsDiv.style.display = 'none';
      weaponsDiv.style.display = 'none';
    }

    function escHandler(e) {
      if (e.key === 'Escape') closePopup();
    }

    popup.style.display = 'block';
    popup.focus();
    institutionPopupOpen = true;
    showInfo();
    document.addEventListener('keydown', escHandler);
    closeBtn.onclick = closePopup;
    const ownerLink = document.getElementById('owner-click');
    if (ownerLink && isOwner) ownerLink.onclick = showWorkforce;
  }

  function updateSinking(dt) {
    for (let i = sinking.length - 1; i >= 0; i--) {
      const s = sinking[i];
      s.t += dt * 5;
      if (s.emit > 0.05 || s.t === 0) {
        const box = new THREE.Box3().setFromObject(s.obj);
        const cx = (box.min.x + box.max.x) / 2;
        const cz = (box.min.z + box.max.z) / 2;
        const y = box.min.y;
        const points = [
          new THREE.Vector3(box.min.x, y, box.min.z),
          new THREE.Vector3(box.min.x, y, box.max.z),
          new THREE.Vector3(box.max.x, y, box.min.z),
          new THREE.Vector3(box.max.x, y, box.max.z),
          new THREE.Vector3(cx, y, box.min.z),
          new THREE.Vector3(cx, y, box.max.z),
          new THREE.Vector3(box.min.x, y, cz),
          new THREE.Vector3(box.max.x, y, cz)
        ];
        points.forEach(p => emitDustParticle(p, 3));
        s.emit = 0;
      }
      s.emit += dt;
      const t = Math.min(s.t, 1);
      s.obj.position.y = THREE.MathUtils.lerp(s.start, s.end, t);
      if (t >= 1) {
        sinking.splice(i, 1);
      }
    }
  }

  function updateInstitutionBoxes() {
    institutionBoxes.forEach(entry => {
      const obj = institutionsMap[entry.id];
      if (obj) entry.box.setFromObject(obj);
    });
  }

  function updateConstructionBoxes() {
    constructionBoxes.forEach(entry => {
      const list = constructionMap[entry.id];
      const c = list && list[entry.index];
      const obj = c && (c.scaff || c.final);
      if (obj) entry.box.setFromObject(obj);
    });
  }

  function handlePendingRemotePlayers() {
    if (!model) return;
    pendingRemotePlayers.forEach(p => createRemotePlayer(p.id, p.state));
    pendingRemotePlayers.length = 0;
  }

  function sendState() {
    if (!socket || socket.readyState !== WebSocket.OPEN || !model) return;
    socket.send(JSON.stringify({
      type: 'state',
      position: [model.position.x, model.position.y, model.position.z],
      rotation: model.rotation.y,
      moving: isMovingForward,
      running: isRunning,
      health,
      hydration,
      oxygen,
      money: playerMoney
    }));
  }

  function sendDestroyInstitution(id) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    socket.send(JSON.stringify({ type: 'destroyInstitution', id }));
  }





  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x775533, 1.2);
  scene.add(hemiLight);

  // Main directional light (sun) - IMPROVED SHADOW SETTINGS
  const sun = new THREE.DirectionalLight(0xffffff, 1.8);
  sun.position.set(20, 30, 15);
  sun.castShadow = true;

  // Improved shadow quality
  sun.shadow.mapSize.width = 4096; // Increased from 2048
  sun.shadow.mapSize.height = 4096; // Increased from 2048
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200; // Extended range
  sun.shadow.camera.left = -100;
  sun.shadow.camera.right = 100;
  sun.shadow.camera.top = 100;
  sun.shadow.camera.bottom = -100;
  sun.shadow.bias = -0.0005; // Helps prevent shadow acne

  scene.add(sun);

  // Uncomment to visualize shadow camera (helpful for debugging)
  // const helper = new THREE.CameraHelper(sun.shadow.camera);
  // scene.add(helper);

  // Additional directional light for better terrain illumination
  const secondaryLight = new THREE.DirectionalLight(0xffd6a5, 1.0); // Warm light
  secondaryLight.position.set(-15, 20, -10); // From opposite direction of sun
  secondaryLight.castShadow = false; // Optional shadow from secondary light
  scene.add(secondaryLight);

  // --- Day/Night Cycle Settings ---
  const DAY_DURATION = 120;   // seconds of daylight
  const NIGHT_DURATION = 120; // seconds of night
  const CYCLE_DURATION = DAY_DURATION + NIGHT_DURATION;
  const SUN_RADIUS = 50;
  const MAX_SUN_INTENSITY = 1.8;
  let dayNightTimer = 0;
  const daySkyColor = new THREE.Color(marsSkyColor);
  const nightSkyColor = new THREE.Color(0x050505);

  function updateDayNightCycle(dt) {
    dayNightTimer = (dayNightTimer + dt) % CYCLE_DURATION;
    const angle = (dayNightTimer / CYCLE_DURATION) * Math.PI * 2;

    // Sun position follows a circular path
    sun.position.set(Math.cos(angle) * SUN_RADIUS, Math.sin(angle) * SUN_RADIUS, 0);
    sun.lookAt(0, 0, 0);

    // Daylight intensity based on sun height
    const daylight = Math.max(0, Math.sin(angle));
    sun.intensity = daylight * MAX_SUN_INTENSITY;
    secondaryLight.intensity = daylight;
    hemiLight.intensity = 0.2 + daylight;

    const skyColor = daySkyColor.clone().lerp(nightSkyColor, 1 - daylight);
    renderer.setClearColor(skyColor);
    scene.fog.color.copy(skyColor);
  }

  // Ground Textures - Load first before terrain
  const textureLoader = new THREE.TextureLoader();
  let diffuseMap = null;
  let bumpMap = null;
  let specMap = null;
  const baseTextureRepeat = 1000; // Base repeat factor for the texture

  // Track texture loading status
  const texturesLoaded = {
    diffuse: false,
    bump: false,
    spec: false
  };

  // Function to check if all textures are loaded and apply them
  function checkTexturesAndApply() {
    if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
      if (gltfTerrain) {
        applyTexturesToTerrain(gltfTerrain);
      }
    }
  }

  // Load diffuse texture (base color)
  textureLoader.load(
    'mars_ground.png',
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      diffuseMap = texture;
      texturesLoaded.diffuse = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.diffuse = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load bump map
  textureLoader.load(
    'mars_ground_bump.png', // Adjust filename to match your bump map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      bumpMap = texture;
      texturesLoaded.bump = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.bump = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load specular map
  textureLoader.load(
    'mars_ground_spec.png', // Adjust filename to match your specular map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      specMap = texture;
      texturesLoaded.spec = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.spec = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load dust particle texture
  let dustTexture;
  textureLoader.load(
    'dust.png',
    (texture) => {
      dustTexture = texture;
      // Initialize dust particles system once texture is loaded
      initDustParticles();
    },
    undefined,
    (error) => {
      // Create a fallback texture - a simple circle
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 24;

      // Draw a simple radial gradient for the particle
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
      gradient.addColorStop(0, 'rgba(255, 230, 200, 1.0)');
      gradient.addColorStop(0.5, 'rgba(230, 200, 170, 0.5)');
      gradient.addColorStop(1, 'rgba(200, 170, 140, 0.0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();

      dustTexture = new THREE.CanvasTexture(canvas);
      initDustParticles();
    }
  );

  // Helper function to apply textures to terrain
  function applyTexturesToTerrain(terrain) {
    terrain.traverse(o => {
      if (o.isMesh) {
        // Create a new material with all textures
        o.material = new THREE.MeshStandardMaterial({
          map: diffuseMap,
          bumpMap: bumpMap,
          bumpScale: 2.3, // Adjust bump intensity
          roughnessMap: specMap, // In PBR, specular is controlled by roughness
          roughness: 5,
          metalness: 0.0,
          color: 0xDC916E // White color to allow texture to show properly
        });
        o.receiveShadow = true; // Make sure terrain receives shadows
        o.material.needsUpdate = true;
      }
    });
  }

  // --- DUST PARTICLES SYSTEM ---
  const MAX_PARTICLES = 300;
  let particleSystem;
  let dustParticles = []; // Array of active particles

  function initDustParticles() {

    // Create a simple points material using the dust texture
    const particleMaterial = new THREE.PointsMaterial({
      size: 1.0,
      map: dustTexture,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true,
      opacity: 0.6,
      sizeAttenuation: true,
      color: 0xbbaa99 // Dusty color
    });

    // Create geometry for the particles
    const particlesGeometry = new THREE.BufferGeometry();

    // Create arrays for positions, sizes, and colors
    const positions = new Float32Array(MAX_PARTICLES * 3);
    const sizes = new Float32Array(MAX_PARTICLES);
    const colors = new Float32Array(MAX_PARTICLES * 3);

    // Initialize all particles to be far below the scene (inactive)
    for (let i = 0; i < MAX_PARTICLES; i++) {
      positions[i * 3] = 0;
      positions[i * 3 + 1] = -1000; // Far below the scene
      positions[i * 3 + 2] = 0;

      sizes[i] = 0;

      // Slightly vary the color of each particle
      const dustColor = new THREE.Color(0xbbaa99);
      dustColor.r *= 0.8 + Math.random() * 0.4;
      dustColor.g *= 0.8 + Math.random() * 0.4;
      dustColor.b *= 0.8 + Math.random() * 0.4;

      colors[i * 3] = dustColor.r;
      colors[i * 3 + 1] = dustColor.g;
      colors[i * 3 + 2] = dustColor.b;

      // Create particle object
      dustParticles.push({
        position: new THREE.Vector3(0, -1000, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        size: 0,
        color: dustColor,
        life: 0,
        maxLife: 2.0,
        active: false,
        index: i
      });
    }

    // Add attributes to the buffer geometry
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create the particle system
    particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    particleSystem.frustumCulled = false; // Prevent particles from disappearing at edge of view
    scene.add(particleSystem);

  }

  // Create new active particles
  function emitDustParticle(position, count = 5) {
    if (!particleSystem) {
      return;
    }

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;

    let emitted = 0;

    // Find inactive particles to reuse
    for (let i = 0; i < dustParticles.length && emitted < count; i++) {
      const particle = dustParticles[i];

      if (!particle.active) {
        // Random offset around the foot position
        const offsetX = (Math.random() - 0.5) * 0.8;
        const offsetZ = (Math.random() - 0.5) * 0.8;

        // Position the particle slightly above ground level
        particle.position.set(
          position.x + offsetX,
          position.y + 0.1, // Higher above ground for visibility
          position.z + offsetZ
        );

        // Random velocity
        particle.velocity.set(
          (Math.random() - 0.5) * 0.6, // More horizontal spread
          Math.random() * 0.5 + 0.2,   // More vertical rise
          (Math.random() - 0.5) * 0.6  // More horizontal spread
        );

        particle.maxLife = 1.0 + Math.random() * 1.5; // 1.0-2.5 seconds
        particle.life = 0;
        particle.size = 0.5;  // Starting size (larger for better visibility)
        particle.active = true;

        // Update the particle data in the buffers
        const idx = particle.index;
        positions[idx * 3] = particle.position.x;
        positions[idx * 3 + 1] = particle.position.y;
        positions[idx * 3 + 2] = particle.position.z;

        sizes[idx] = particle.size;

        emitted++;
      }
    }

    // Mark attributes as needing update
    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.size.needsUpdate = true;

  }

  // Update particles every frame
  function updateParticles(dt) {
    if (!particleSystem) return;

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;
    let needsUpdate = false;

    // Update each active particle
    for (let i = 0; i < dustParticles.length; i++) {
      const particle = dustParticles[i];

      if (particle.active) {
        // Update particle life
        particle.life += dt;

        if (particle.life >= particle.maxLife) {
          // Deactivate the particle
          particle.active = false;

          // Move it far below scene
          particle.position.y = -1000;
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          sizes[i] = 0;
          needsUpdate = true;
        } else {
          // Calculate life progress (0 to 1)
          const t = particle.life / particle.maxLife;

          // Update position with velocity
          particle.position.x += particle.velocity.x * dt;
          particle.position.y += particle.velocity.y * dt;
          particle.position.z += particle.velocity.z * dt;

          // Air resistance / drag
          particle.velocity.multiplyScalar(0.95);

          // Gravity effect - slow down ascent
          particle.velocity.y -= 0.1 * dt;

          // Calculate size and opacity based on life cycle
          // Start small, grow, then shrink
          let size;
          if (t < 0.2) {
            // Grow quickly at start
            size = (t / 0.2) * 2.0;
          } else if (t > 0.8) {
            // Shrink at end
            size = 2.0 * (1.0 - (t - 0.8) / 0.2);
          } else {
            // Maintain size in middle
            size = 2.0;
          }

          // Update size (larger and more visible)
          particle.size = size;
          sizes[i] = size;

          // Update position in buffer
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          needsUpdate = true;
        }
      }
    }

    // Only update buffers if needed
    if (needsUpdate) {
      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.geometry.attributes.size.needsUpdate = true;
    }
  }

  // --- PHYSICS AND GRAVITY SETTINGS ---
  const gravity = 3.7; // Mars gravity (lower than Earth's 9.8)
  const groundCheckDistance = 2.0; // Slightly increased for stability
  let velocity = new THREE.Vector3(0, 0, 0);
  let onGround = false;
  let groundY = null; // To track stable ground height
  const groundDamping = 1; // Dampening factor (0.0 to 1.0) - higher means less bounce
  const initialFallHeight = 100; // Reasonable height to start falling from

  // Raycaster for ground detection
  const raycaster = new THREE.Raycaster();

  // --- LOAD GLTF GROUND MODEL ---
  const groundLoader = new GLTFLoader();
  let gltfTerrain;
  const terrainScaleFactor = 50; // Adjust this to scale your terrain

  // Array to store all terrain meshes for raycasting
  const terrainMeshes = [];

  groundLoader.load(
    'terrain_s.gltf', // Replace this with the path to your ground GLTF file
    (gltf) => {
      gltfTerrain = gltf.scene;
      addPointLightsFromGLTF(gltf);

      gltfTerrain.scale.set(terrainScaleFactor, terrainScaleFactor, terrainScaleFactor);

      // Optional: Adjust terrain position if needed
      // gltfTerrain.position.y = -someValueToCorrect;

      gltfTerrain.traverse(o => {
        if (o.isMesh) {
          o.receiveShadow = true;
          o.castShadow = false;

          // Add mesh to our array for raycasting
          terrainMeshes.push(o);
        }
      });

      // Apply textures if they're already loaded
      if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
        applyTexturesToTerrain(gltfTerrain);
      }

      scene.add(gltfTerrain);

      // Position model on the terrain if it's already loaded
      if (model) {
        findGroundBelow();
      }
    },
    undefined,
    (error) => {
      // Create a fallback terrain with some hills
      createFallbackTerrain();
    }
  );

  // Create a fallback procedural terrain with variation for testing
  function createFallbackTerrain() {
    // Create a larger, more detailed fallback ground with some hills
    const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);

    // Add some hills and valleys
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
      // Skip the edges to keep them flat
      const x = vertices[i];
      const z = vertices[i+2];
      if (Math.abs(x) < 90 && Math.abs(z) < 90) {
        // Create some hills using sine waves
        vertices[i+1] = Math.sin(x * 0.1) * 3 + Math.sin(z * 0.1) * 3;
      }
    }

    // Important: update normals after modifying vertices
    groundGeometry.computeVertexNormals();

    // Create material with available textures
    const groundMaterial = new THREE.MeshStandardMaterial({
      roughness: 0.8,
      metalness: 0.2
    });

    // Apply textures to fallback terrain if available
    if (diffuseMap) {
      groundMaterial.map = diffuseMap;
      groundMaterial.map.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    } else {
      groundMaterial.color.set(0x553311);
    }

    if (bumpMap) {
      groundMaterial.bumpMap = bumpMap;
      groundMaterial.bumpScale = 0.5;
      groundMaterial.bumpMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    if (specMap) {
      groundMaterial.roughnessMap = specMap;
      groundMaterial.roughnessMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    const fallbackGround = new THREE.Mesh(groundGeometry, groundMaterial);
    fallbackGround.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    fallbackGround.receiveShadow = true;
    scene.add(fallbackGround);

    // Add to terrainMeshes for raycasting
    terrainMeshes.push(fallbackGround);


    // Position the model if it's already loaded
    if (model) {
      findGroundBelow();
    }
  }

  // Player model and animations
  let model, mixer;
  let runAction, walkAction, idleAction, dieAction, flagPlantAction;
  let activeAction;
  const modelScale = 1.2;
  const characterHeight = 1.8 * modelScale; // Approximate height of character
  const characterRadius = 0.5 * modelScale; // Radius used for collision checks
  let playerAnimations = null;

  // Track foot positions for dust particles
  const footPositions = {
    left: new THREE.Vector3(),
    right: new THREE.Vector3(),
    lastEmitTime: 0
  };

  // Load player model
  new GLTFLoader().load(
    'character.glb',
    gltf => {
      model = gltf.scene;
      addPointLightsFromGLTF(gltf);
      model.scale.set(modelScale, modelScale, modelScale);
      model.rotation.y =0
      // Setup shadow casting
      model.traverse(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = false;

          const oldMat = o.material;
          if (oldMat && !oldMat.isMeshStandardMaterial) {
            o.material = new THREE.MeshStandardMaterial({
              map: oldMat.map || null,
              color: oldMat.color ? oldMat.color.clone() : new THREE.Color(0xffffff),
              metalness: 0.2,
              roughness: 0.8,
              skinning: !!o.isSkinnedMesh
            });
          }
        }
      });
      scene.add(model);

      // Footstep audio attached to the player
      footstepSound = new THREE.PositionalAudio(listener);
      audioLoader.load('walking.mp3', buffer => {
        footstepSound.setBuffer(buffer);
        footstepSound.setLoop(true);
        footstepSound.setRefDistance(5);
        footstepSound.setVolume(0);
        footstepSound.play();
      });
      model.add(footstepSound);

      // Debug: log when player model is loaded and its starting position
      if (DEBUG_LOG) {
        console.log('[DEBUG] Player model loaded', {
          position: {
            x: startPosition[0],
            y: startPosition[1],
            z: startPosition[2]
          }
        });
      }

      // Position the model based on saved state
      model.position.set(startPosition[0], startPosition[1], startPosition[2]);

      // Setup animations
      mixer = new THREE.AnimationMixer(model);
      const animations = gltf.animations;
      idleAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'idle'));
      walkAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'walk'));
      runAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'run'));
      dieAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'die'));
      flagPlantAction = mixer.clipAction(animations.find(a => a.name.toLowerCase() === 'target'));
      if (flagPlantAction) {
        flagPlantAction.setLoop(THREE.LoopOnce, 1);
        flagPlantAction.clampWhenFinished = true;
      }
      if (dieAction) {
        dieAction.setLoop(THREE.LoopOnce, 1);
        dieAction.clampWhenFinished = true;
      }
      playerAnimations = animations;


      // Set up animation events for dust particles
      if (runAction || walkAction) {
        // Add an event that fires at specific points in animation
        // (these numbers would need adjustment based on the actual animation)
        const leftFootStep = 0.3; // 30% through animation
        const rightFootStep = 0.8; // 80% through animation

        // Set up animation events using mixer
        mixer.addEventListener('loop', function(e) {
          if ((e.action === runAction || e.action === walkAction) && isMovingForward && onGround) {
            // Calculate foot positions and emit dust at each step
            calculateFootPositions();
          }
        });
      }

      activeAction = idleAction || walkAction || runAction;
      if (activeAction) activeAction.play();

      // If terrain is already loaded, we can find the ground
      if (terrainMeshes.length > 0) {
        findGroundBelow();
      }
      handlePendingRemotePlayers();
    },
    undefined,
  );

  // Calculate foot positions based on model
  function calculateFootPositions() {
    if (!model) return;

    // Get model's world position
    const modelPosition = model.position.clone();
    const modelDirection = new THREE.Vector3(0, 0, -1);
    modelDirection.applyQuaternion(model.quaternion);

    // Calculate basic foot positions (slightly behind model for walking)
    // This is an approximation - would be better with actual bone positions
    const footOffset = 0.5 * modelScale;

    // Position for left foot
    footPositions.left.set(
      modelPosition.x - modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z + modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Position for right foot
    footPositions.right.set(
      modelPosition.x + modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z - modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Emit particles at both feet
    emitDustParticle(footPositions.left, 10); // Emit more particles for better visibility
    emitDustParticle(footPositions.right, 10);

  }

  /**
   * Finds the ground below the character without teleporting to it
   * Just identifies where the ground is for physics to work with
   */
  function findGroundBelow() {
    if (!model || terrainMeshes.length === 0) return;

    // Use the actual current position of the model
    const origin = model.position.clone();

    // Cast ray downward from current position
    raycaster.set(
      origin,
      new THREE.Vector3(0, -1, 0) // Direction straight down
    );

    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    if (intersects.length > 0) {
      // We found ground - but we won't teleport to it
      // Just let gravity do its work in the animation loop

      // We're not on ground yet - we're still falling
      onGround = false;
    } else {
    }
  }

  // Input state
  const keys = { w: false, a: false, s: false, d: false, arrowup: false, arrowleft: false, arrowright: false, arrowdown: false, space: false, shift: false };
  window.addEventListener('keydown', e => {
    if (institutionPopupOpen) return;
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = true;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = true;
    if (e.code === 'KeyK') {
      if (DEBUG_LOG) console.log('[DEBUG] Key K pressed');
      fireAllWeapons();
    } else if (e.code === 'KeyT') {
      if (DEBUG_LOG) console.log('[DEBUG] Key T pressed');
      plantFlag();
    }
  });
  window.addEventListener('keyup', e => {
    if (institutionPopupOpen) return;
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = false;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.shift = false;
  });

  // Camera and movement settings
  const camOffset = new THREE.Vector3(0, 2.0 * modelScale, -5.0 * modelScale);
  const modelLookAtHeight = 1.5 * modelScale;
  const clock = new THREE.Clock();
  let isMovingForward = false;
  let isRunning = false;
  const walkSpeed = 3.0 * modelScale;
  const runSpeed = 6.0 * modelScale;
  let lastPosition = new THREE.Vector3();
  let timeSinceLastEmit = 0;

  function switchAnimation(actionToPlay) {
    if (activeAction === actionToPlay || !actionToPlay) return;
    if (activeAction) activeAction.fadeOut(0.2);
    actionToPlay.reset().fadeIn(0.2).play();
    activeAction = actionToPlay;
  }

  /**
   * Checks if character is in contact with the ground
   * Called every frame in the animation loop
   */
  function checkGroundContact() {
    if (!model) return;

    // Origin is at character's feet plus half height (center of character)
    const origin = model.position.clone();
    origin.y += characterHeight / 2;

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    // Check if we're on or near ground
    if (intersects.length > 0 && intersects[0].distance <= groundCheckDistance) {
      const groundPosition = intersects[0].point.y;

      // Handle initial ground contact
      if (!onGround) {
          velocity.y = 0;
          onGround = true;

      } else {
        // Already on ground - stabilize position with smooth interpolation
        if (groundY === null) {
          groundY = groundPosition;
        } else {
          // Smoothly interpolate ground height to prevent jitter
          groundY = groundY * 0.9 + groundPosition * 0.1;
        }

        // Smoothly set character position
        model.position.y = groundY;
        velocity.y = 0;
      }
    } else {
      // Not touching ground
      onGround = false;
      groundY = null;
    }
  }

  // Update alignment with terrain after horizontal movement
  function updateTerrainAlignment() {
    if (!model) return;

    // Only check terrain alignment if we're on the ground
    if (!onGround) return;

    // Origin at character's feet
    const origin = model.position.clone();
    origin.y += 0.5 * characterHeight; // Start from middle of character

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    if (intersects.length > 0) {
      const targetY = intersects[0].point.y;

      // Smooth interpolation of height change for walking on uneven terrain
      if (groundY === null) {
        groundY = targetY;
      } else {
        // Adjust smoothing factor based on how fast we're moving
        // More smoothing (smaller factor) for faster movement to reduce jitter
        const smoothFactor = isMovingForward ? 0.15 : 0.3;
        groundY = groundY * (1 - smoothFactor) + targetY * smoothFactor;
      }

      // Apply smoothed position
      model.position.y = groundY;
    }
  }

  function updateCamera(dt) {
    if (!model) return;

    const modelWorldPosition = new THREE.Vector3();
    model.getWorldPosition(modelWorldPosition);

    // Apply camera offset in model's local space
    const desiredCamPos = modelWorldPosition.clone().add(
      camOffset.clone().applyQuaternion(model.quaternion)
    );

    // Smoother camera lerp
    camera.position.lerp(desiredCamPos, 5 * dt);

    // Look at point slightly above character's feet
    const lookAtPoint = modelWorldPosition.clone();
    lookAtPoint.y += modelLookAtHeight;
    camera.lookAt(lookAtPoint);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    updateDayNightCycle(dt);

    // Update particles
    updateParticles(dt);
    updateProjectiles(dt);
    updateSinking(dt);
    updateInstitutionBoxes();
    updateConstructionBoxes();

    if (mixer) mixer.update(dt);
    for (const id in remotePlayers) {
      remotePlayers[id].mixer.update(dt);
    }
    for (const id in institutionMixers) {
      institutionMixers[id].update(dt);
    }
    for (const id in weaponMixers) {
      const arr = weaponMixers[id];
      if (Array.isArray(arr)) arr.forEach(m => m.update(dt));
    }
    if (ghostMixer) ghostMixer.update(dt);

    if (model && terrainMeshes.length > 0) {
        // PHYSICS - Apply gravity if not on ground
        if (!onGround) {
            velocity.y -= gravity * dt;

            // Apply velocity (for falling)
            model.position.y += velocity.y * dt;

            // Force idle animation when in the air
            if (idleAction && activeAction !== idleAction) {
                switchAnimation(idleAction);
                // We're not moving forward when in the air
                isMovingForward = false;
            }
        }

        // Check if on ground after applying gravity
        checkGroundContact();

        // Controls and movement - only process when on ground
        if ((idleAction || walkAction || runAction) && onGround) {
            // Save last position for movement detection
            lastPosition.copy(model.position);

            const turnSpeed = (Math.PI); // Adjusted turn speed a bit

            let wantsToMoveForward = keys.w || keys.up;
            let wantsToMoveBackward = keys.s || keys.down;
            let turnLeft = keys.a || keys.left;
            let turnRight = keys.d || keys.right;

            // Handle turning
            if (turnLeft) model.rotation.y += turnSpeed * dt;
            if (turnRight) model.rotation.y -= turnSpeed * dt;

            // Movement
            let moving = false;
            let moveDir = new THREE.Vector3(0, 0, 0);
            let moveAction = idleAction;

            if (wantsToMoveForward) {
                // Fixed direction to go forward from model perspective
                moveDir.z = 1;
                moving = true;
                isRunning = keys.shift;
                moveAction = isRunning ? runAction : walkAction;
            } else if (wantsToMoveBackward) {
                moveDir.z = -0.5;
                moving = true;
                isRunning = false;
                moveAction = walkAction || runAction;
            }

            // Apply movement in model's local direction
            if (moving) {
                const speed = isRunning ? runSpeed : walkSpeed;
                if (activeAction !== moveAction && moveAction) {
                    switchAnimation(moveAction);
                }
                isMovingForward = true;

                // Transform direction to world space
                moveDir.applyQuaternion(model.quaternion);
                moveDir.normalize();

                // Store current position before movement
                const oldPos = model.position.clone();

                const proposed = model.position.clone().add(moveDir.clone().multiplyScalar(speed * dt));
                let blocked = false;
                const sphereCenter = proposed.clone();
                sphereCenter.y += characterHeight / 2;
                const sphere = new THREE.Sphere(sphereCenter, characterRadius);
                institutionBoxes.forEach(entry => {
                    if (entry.box.intersectsSphere(sphere)) blocked = true;
                });
                constructionBoxes.forEach(entry => {
                    if (entry.box.intersectsSphere(sphere)) blocked = true;
                });
                if (!blocked) {
                    model.position.copy(proposed);
                }

                // Update terrain alignment after horizontal movement
                if (onGround) {
                    updateTerrainAlignment();

                    // Emit dust particles when walking on ground
                    timeSinceLastEmit += dt;
                    if (timeSinceLastEmit > 0.1) { // More frequent emission (was 0.2)
                        calculateFootPositions();
                        timeSinceLastEmit = 0;

                        // Debug log for dust emission
                        if (isMovingForward && onGround) {
                        }
                    }
                }
            } else if (isMovingForward && idleAction) {
                // Switch to idle when not moving
                switchAnimation(idleAction);
                isMovingForward = false;
                isRunning = false;
            }

            if (footstepSound) {
                const vol = (isMovingForward && onGround) ? 1 : 0;
                footstepSound.setVolume(vol);
            }
        }

        if (model.position.y < -100) {
          model.position.y = 60;
          velocity.y = 0;
          groundY = null;
          onGround = false;
        }

        // Camera follow
        updateCamera(dt);
        updateGhostInstitution();
        if (!dead) {
          sendState();
          updateStats();
          institutionFrame++;
          if (institutionFrame >= INSTITUTION_INTERVAL_FRAMES) {
            applyInstitutionEffects();
            institutionFrame = 0;
          }
        }
        else {
          sendState();
        }
    }

    // Debug rendering to visualize particle positions
    if (particleSystem && particleSystem.geometry) {
      const positions = particleSystem.geometry.attributes.position.array;
      const sizes = particleSystem.geometry.attributes.size.array;

      // Count active particles
      let activeCount = 0;
      for (let i = 0; i < dustParticles.length; i++) {
        if (dustParticles[i].active) activeCount++;
      }

      if (activeCount > 0 && model) {
      }
    }

    // Render using composer for bloom effect
    composer.render();
}

  animate();

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);

    ssaoPass.setSize(window.innerWidth, window.innerHeight);

    // Update bloom pass resolution
    bloomPass.resolution.set(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>