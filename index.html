<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Mars Runner</title>
  <link rel="stylesheet" href="style.css">
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.176.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.176.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="login-container" class="login-container">
    <div class="login-box">
      <input type="email" id="login-email" placeholder="Email" />
      <button id="send-code">Send Code</button>
      <div id="code-section" class="hidden">
        <input type="text" id="login-code" placeholder="Code" />
        <button id="verify-code">Verify</button>
      </div>
      <div id="login-error"></div>
    </div>
  </div>
  <div id="money-display">Money: 0</div>
  <div id="status-panel">
    <div class="stat"><img id="health-img" /></div>
    <div class="stat"><img id="hydration-img" /></div>
    <div class="stat"><img id="oxygen-img" /></div>
  </div>
  <div id="low-oxygen-overlay"></div>
  <div id="death-overlay">
    <div>You died</div>
    <button id="respawn-btn">Respawn for 1000</button>
  </div>
  <div id="institution-panel" class="side-panel panel">
    <div class="panel-tab">Institutions</div>
    <div class="panel-content" id="institution-content"></div>
  </div>
    <div id="institution-popup" class="panel">
    <div id="popup-close" >X</div>
    <div id="popup-info">
      <div id="popup-owner"></div>
      <div id="popup-resources"></div>
      <div id="popup-workforce-carousel" ></div>
    </div>
    <div id="popup-workforce" class="hidden">
      <div id="workforce-container" ></div>
    </div>
    <div id="popup-chat" class="hidden">
      <div id="chat-container"></div>
    </div>
    <div id="popup-proposals" class="hidden">
      <div id="proposals-container"></div>
    </div>
          <div class="popup-actions">
      <button id="info-tab-btn">Info</button>
      <button id="workforce-tab-btn">See Applicants</button>
      <button id="chat-tab-btn">Chat</button>
      <button id="proposals-tab-btn">Proposals</button>
    </div>
  </div>
  <script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
  import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
  import { renderProposals } from './proposals.js';

  let playerEmail = null;
  let playerMoney = 0;
  let startPosition = [70, 100, -50];

const icons = {
  health_full: 'healthfull.png',
  health_half: 'healthhalf.png',
  health_low: 'healthlow.png',
  hydration_full: 'watfull.png',
  hydration_half: 'wathalf.png',
  hydration_low: 'watlow.png',
  oxygen_full: 'o2full.png',
  oxygen_half: 'o2half.png',
  oxygen_low: 'o2low.png'
};

  const healthImg = document.getElementById('health-img');
  const hydrationImg = document.getElementById('hydration-img');
  const oxygenImg = document.getElementById('oxygen-img');
  const lowOxygenOverlay = document.getElementById('low-oxygen-overlay');
  const deathOverlay = document.getElementById('death-overlay');
  const respawnBtn = document.getElementById('respawn-btn');

  let health = 1000;
  let hydration = 1000;
  let oxygen = 1000;
  let dead = false;

  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  function fadeSwap(img, src) {
    if (img.dataset.current === src) return;
    img.style.opacity = 0;
    setTimeout(() => {
      img.src = src;
      img.dataset.current = src;
      img.style.opacity = 1;
    }, 100);
  }

function updateStatImages() {
  // Use percentage calculation with better boundaries
  const healthPct = (health / 100) * 100;  // Convert to 0-100 percentage
  const hydPct = (hydration / 100) * 100;
  const oxyPct = (oxygen / 100) * 100;

  // Health image logic
  let healthSrc = icons.health_low;
  if (healthPct >= 66) healthSrc = icons.health_full;      // 66-100%
  else if (healthPct >= 33) healthSrc = icons.health_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(healthImg, healthSrc);

  // Hydration image logic
  let hydSrc = icons.hydration_low;
  if (hydPct >= 66) hydSrc = icons.hydration_full;      // 66-100%
  else if (hydPct >= 33) hydSrc = icons.hydration_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(hydrationImg, hydSrc);

  // Oxygen image logic
  let oxySrc = icons.oxygen_low;
  if (oxyPct >= 66) oxySrc = icons.oxygen_full;      // 66-100%
  else if (oxyPct >= 33) oxySrc = icons.oxygen_half; // 33-65%
  // else shows low (0-32%)
  fadeSwap(oxygenImg, oxySrc);

  // Debug logging to help track issues
}

  function updateMoneyDisplay() {
    document.getElementById('money-display').textContent = `Money: ${playerMoney}`;
    updateInstitutionTiles();
  }

  respawnBtn.onclick = () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: 'respawn' }));
    }
  };

  async function autoLogin(email) {
    try {
      const res = await fetch('/api/state/' + encodeURIComponent(email));
      if (!res.ok) throw new Error('state');
      const data = await res.json();
      startPosition = data.position;
      playerMoney = data.money || 0;
      health = data.health || 1000;
      hydration = data.hydration || 1000;
      oxygen = data.oxygen || 1000;
      updateStatImages();
      playerEmail = email;
      document.getElementById('login-container').style.display = 'none';
      initNetwork();
      updateMoneyDisplay();
      return true;
    } catch {
      return false;
    }
  }

  const stored = localStorage.getItem('playerEmail');
  if (stored) {
    autoLogin(stored);
  }

    // --- Institution placement ---
  const institutions = [
    {
      name: 'WatOx',
      url: 'WATOX.glb',
      thumbnail: 'watox.png',
      scale: 7,
      price: 100,
      effects: { hydration: 0.5, oxygen: 0.5 }
    },
    {
      name: 'Lab',
      url: 'https://threejs.org/examples/models/gltf/Flamingo.glb',
      thumbnail: 'https://placehold.co/100x100?text=Lab',
      scale: 0.5,
      price: 200,
      effects: { health: 0.2 }
    },
    {
      name: 'Depot',
      url: 'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
      thumbnail: 'https://placehold.co/100x100?text=Depot',
      scale: 0.8,
      price: 150,
      effects: { money: 1 }
    }
  ];

  const panel = document.getElementById('institution-panel');
  const panelTab = panel.querySelector('.panel-tab');
  const panelContent = document.getElementById('institution-content');
  panelTab.addEventListener('click', () => {
    panel.classList.toggle('open');
  });

  const institutionTiles = [];
  const ownedInstitutions = [];
  const INSTITUTION_INTERVAL_FRAMES = 60;
  let institutionFrame = 0;
  institutions.forEach(inst => {
    const tile = document.createElement('div');
    tile.className = 'institution-tile';
    const img = document.createElement('img');
    img.src = inst.thumbnail;
    img.alt = inst.name;
    tile.appendChild(img);
    const label = document.createElement('div');
    label.textContent = `${inst.name} ($${inst.price})`;
    tile.appendChild(label);
    const overlay = document.createElement('div');
    overlay.className = 'institution-overlay';
    overlay.innerHTML = '<div>Not enough money</div><button>Request partners</button>';
    tile.appendChild(overlay);
    tile.addEventListener('click', () => {
      if (playerMoney >= inst.price) {
        selectInstitution(inst);
      }
    });
    panelContent.appendChild(tile);
    institutionTiles.push({ tile, overlay, inst });
  });

  function updateInstitutionTiles() {
    institutionTiles.forEach(t => {
      if (playerMoney >= t.inst.price) {
        t.overlay.style.display = 'none';
      } else {
        t.overlay.style.display = 'flex';
      }
    });
  }

  let ghostInstitution = null;
  let placingInstitution = false;
  let currentInstitution = null;
  let institutionPopupOpen = false;

  function selectInstitution(inst) {
    if (ghostInstitution) {
      scene.remove(ghostInstitution);
      ghostInstitution = null;
    }
    const loader = new GLTFLoader();
    loader.load(inst.url, gltf => {
      ghostInstitution = gltf.scene;
      ghostInstitution.scale.setScalar(inst.scale || 1);
      ghostInstitution.traverse(o => {
        if (o.isMesh) {
          o.material = o.material.clone();
          o.material.transparent = true;
          o.material.opacity = 0.5;
          o.castShadow = true;
          o.receiveShadow = true;
        }
      });
      scene.add(ghostInstitution);
      placingInstitution = true;
      currentInstitution = inst;
    });
  }

  function handleClick(event) {
    if (institutionPopupOpen) return;
    if (placingInstitution && ghostInstitution && currentInstitution) {
      if (playerMoney < currentInstitution.price) {
        alert('Not enough money');
        return;
      }
      const box = new THREE.Box3().setFromObject(ghostInstitution);
      const height = box.max.y - box.min.y;
      const ground = getGroundHeightAt(ghostInstitution.position.x, ghostInstitution.position.z);
      const targetY = ground - height * 0.2;
      const data = {
        type: 'addInstitution',
        name: currentInstitution.name,
        position: [ghostInstitution.position.x, targetY, ghostInstitution.position.z],
        rotation: ghostInstitution.rotation.y,
        scale: currentInstitution.scale
      };
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify(data));
      }
      scene.remove(ghostInstitution);
      ghostInstitution = null;
      placingInstitution = false;
      currentInstitution = null;
      return;
    }

    // Raycast to detect institution click
    const mouse = new THREE.Vector2(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1
    );
    raycaster.setFromCamera(mouse, camera);
    const objs = Object.values(institutionsMap);
    const intersects = raycaster.intersectObjects(objs, true);
    if (intersects.length > 0) {
      let obj = intersects[0].object;
      while (obj && obj.userData && obj.userData.institutionId === undefined) {
        obj = obj.parent;
      }
      if (obj && obj.userData && obj.userData.institutionId !== undefined) {
        showInstitutionPopup(obj.userData.institutionId);
      }
    }
  }

  window.addEventListener('click', handleClick);

  function updateGhostInstitution() {
    if (!placingInstitution || !ghostInstitution || !model) return;
    const offset = new THREE.Vector3(0, 3, -20);
    offset.applyQuaternion(model.quaternion);
    const target = model.position.clone().add(offset);
    ghostInstitution.position.copy(target);
    ghostInstitution.rotation.y = model.rotation.y;
  }

  function getGroundHeightAt(x, z) {
    if (terrainMeshes.length === 0) return 0;
    const origin = new THREE.Vector3(x, 1000, z);
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const hits = raycaster.intersectObjects(terrainMeshes, true);
    if (hits.length > 0) {
      return hits[0].point.y;
    }
    return 0;
  }

  function updateStats() {
    if (dead) return;
    if (isMovingForward) {
      hydration = Math.max(hydration - 0.05, 0);
      oxygen = Math.max(oxygen - 0.02, 0);
    } else {
      hydration = Math.max(hydration - 0.02, 0);
      oxygen = Math.max(oxygen - 0.005, 0);
    }

    if (oxygen <= 10) lowOxygenOverlay.style.display = 'block';
    else lowOxygenOverlay.style.display = 'none';

    const canvas = renderer.domElement;
    if (hydration <= 20) {
      const maxBlur = 30;
      const blurAmount = maxBlur * (1 - hydration / 20);
      canvas.style.filter = `blur(${blurAmount.toFixed(1)}px)`;
    } else {
      canvas.style.filter = '';
    }

    if (oxygen <= 0 || hydration <= 0) {
      dead = true;
      deathOverlay.style.display = 'flex';
    }

    updateStatImages();
  }

  function applyInstitutionEffects() {
    ownedInstitutions.forEach(e => {
      if (e.hydration) hydration = Math.min(hydration + e.hydration, 1000);
      if (e.oxygen) oxygen = Math.min(oxygen + e.oxygen, 1000);
      if (e.health) health = Math.min(health + e.health, 1000);
      if (e.money) {
        playerMoney += e.money;
        updateMoneyDisplay();
      }
    });

    // Workforce resource consumption
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => {
          if (!w.effects) return;
          if (w.effects.hydration) hydration = Math.max(hydration + w.effects.hydration, 0);
          if (w.effects.oxygen) oxygen = Math.max(oxygen + w.effects.oxygen, 0);
          if (w.effects.health) health = Math.max(health + w.effects.health, 0);
        });
      }
    });

    // Pay workforce wages
    let wages = 0;
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === playerEmail && Array.isArray(d.workforce)) {
        d.workforce.forEach(w => { wages += w.wage || 0; });
      }
    });
    if (wages > 0) {
      playerMoney = Math.max(playerMoney - wages, 0);
      updateMoneyDisplay();
    }
    updateStatImages();
  }

  async function startVerification(email) {
    const res = await fetch('/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    return res.ok;
  }

  async function verifyCode(email, code) {
    const res = await fetch('/api/verify', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, code })
    });
    if (!res.ok) throw new Error('verify');
    const data = await res.json();
    startPosition = data.user.position;
    playerMoney = data.user.money || 0;
    health = data.user.health || 1000;
    hydration = data.user.hydration || 1000;
    oxygen = data.user.oxygen || 1000;
    updateStatImages();
    playerEmail = email;
    localStorage.setItem('playerEmail', email);
    document.getElementById('login-container').style.display = 'none';
    initNetwork();
    updateMoneyDisplay();
  }

  document.getElementById('send-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    if (await startVerification(email)) {
      document.getElementById('code-section').style.display = 'block';
    }
  };

  document.getElementById('verify-code').onclick = async () => {
    const email = document.getElementById('login-email').value;
    const code = document.getElementById('login-code').value;
    try {
      await verifyCode(email, code);
    } catch (e) {
      document.getElementById('login-error').textContent = 'Verification failed';
    }
  };

  // Scene, camera, renderer
  const scene = new THREE.Scene();
  const marsSkyColor = 0x9B7653; // Dusty orange-red for Mars sky
  // Adjusted fog for potentially larger terrain
  scene.fog = new THREE.FogExp2(marsSkyColor, 0.0003); // Lower density for more view distance

  // Adjusted camera far plane for potentially larger terrain
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 10, 15);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Better shadows
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(marsSkyColor);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  // Post-processing setup for bloom
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  // Bloom effect
  const bloomParams = {
    strength: 0.1,
    radius: 0.7,
    threshold: 0.8
  };
  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    bloomParams.strength,
    bloomParams.radius,
    bloomParams.threshold
  );
  composer.addPass(bloomPass);

  // Output pass to properly handle tone mapping
  const outputPass = new OutputPass();
  composer.addPass(outputPass);

  // --- Multiplayer Networking ---
  let socket;
  let clientId = null;
  const remotePlayers = {};
  const pendingRemotePlayers = [];
  const institutionsMap = {};
  const institutionDataMap = {};
  const institutionBoxes = [];
  const constructionBoxes = [];
  const sinking = [];
  const constructionMap = {}; // id -> array of {scaff, final}

  function initNetwork() {
    socket = new WebSocket('ws://localhost:3000?email=' + encodeURIComponent(playerEmail));
    socket.addEventListener('message', e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'welcome') {
        clientId = msg.id;
        msg.players.forEach(p => createRemotePlayer(p.id, p));
        if (msg.institutions) {
          msg.institutions.forEach(i => createInstitution(i, false));
        }
        if (typeof msg.money === 'number') {
          playerMoney = msg.money;
          updateMoneyDisplay();
        }
        if (typeof msg.health === 'number') health = msg.health;
        if (typeof msg.hydration === 'number') hydration = msg.hydration;
        if (typeof msg.oxygen === 'number') oxygen = msg.oxygen;
        updateStatImages();
      } else if (msg.type === 'spawn') {
        createRemotePlayer(msg.id);
      } else if (msg.type === 'update') {
        if (msg.id !== clientId) updateRemotePlayer(msg.id, msg);
      } else if (msg.type === 'remove') {
        removeRemotePlayer(msg.id);
      } else if (msg.type === 'addInstitution') {
        createInstitution(msg.institution, true);
      } else if (msg.type === 'updateInstitution') {
        const inst = institutionDataMap[msg.id];
        if (inst) {
          inst.extraEffects = msg.extraEffects || inst.extraEffects || {};
          if (msg.construction !== undefined) {
            if (!Array.isArray(inst.constructions)) inst.constructions = [];
            inst.constructions[msg.index] = msg.construction;
            applyConstruction(inst);
          }
          if (inst.owner === playerEmail && msg.gains) {
            ownedInstitutions.push(msg.gains);
          }
        }
      } else if (msg.type === 'money') {
        playerMoney = msg.money;
        updateMoneyDisplay();
      } else if (msg.type === 'respawn') {
  dead = false;
  deathOverlay.style.display = 'none';

  // Set values
  oxygen = msg.oxygen;
  hydration = msg.hydration;
  health = msg.health;
  playerMoney = msg.money;

  // Clear effects
  renderer.domElement.style.filter = '';
  lowOxygenOverlay.style.display = 'none';

  // FORCE RESET IMAGES - DIRECT APPROACH
  healthImg.dataset.current = '';  // Clear cache
  hydrationImg.dataset.current = '';
  oxygenImg.dataset.current = '';

  // DIRECTLY SET TO FULL IMAGES
  healthImg.src = icons.health_full;
  healthImg.dataset.current = icons.health_full;
  hydrationImg.src = icons.hydration_full;
  hydrationImg.dataset.current = icons.hydration_full;
  oxygenImg.src = icons.oxygen_full;
  oxygenImg.dataset.current = icons.oxygen_full;

  updateMoneyDisplay();
}
    });
  }

  function createRemotePlayer(id, state) {
    if (!model) {
      pendingRemotePlayers.push({ id, state });
      return;
    }
    if (remotePlayers[id]) return;
    const remote = SkeletonUtils.clone(model);
    scene.add(remote);
    const m = new THREE.AnimationMixer(remote);
    let idle, run;
    if (playerAnimations) {
      const idleClip = playerAnimations.find(a => a.name === 'Idle');
      const runClip = playerAnimations.find(a => a.name === 'Run');
      if (idleClip) idle = m.clipAction(idleClip);
      if (runClip) run = m.clipAction(runClip);
    }
    if (idle) idle.play();
    remotePlayers[id] = { model: remote, mixer: m, idle, run, active: idle };
    if (state) {
      remote.position.fromArray(state.position);
      remote.rotation.y = state.rotation;
    }
  }

  function updateRemotePlayer(id, state) {
    const rp = remotePlayers[id];
    if (!rp) return;
    rp.model.position.fromArray(state.position);
    rp.model.rotation.y = state.rotation;
    if (typeof state.moving === 'boolean') {
      const target = state.moving ? rp.run : rp.idle;
      if (target && rp.active !== target) {
        rp.active && rp.active.fadeOut(0.2);
        target.reset().fadeIn(0.2).play();
        rp.active = target;
      }
    }
  }

  function removeRemotePlayer(id) {
    const rp = remotePlayers[id];
    if (!rp) return;
    scene.remove(rp.model);
    delete remotePlayers[id];
  }

  function removeConstructionBoxes(id) {
    for (let i = constructionBoxes.length - 1; i >= 0; i--) {
      if (constructionBoxes[i].id === id) constructionBoxes.splice(i, 1);
    }
  }

  function applyConstruction(inst) {
    const existing = constructionMap[inst.id] || [];
    existing.forEach(e => {
      if (e.scaff) scene.remove(e.scaff);
      if (e.final) scene.remove(e.final);
    });
    removeConstructionBoxes(inst.id);
    constructionMap[inst.id] = [];
    if (!Array.isArray(inst.constructions)) return;
    inst.constructions.forEach((c, idx) => {
      if (!c) return;
      const loader = new GLTFLoader();
      loader.load(c.url, gltf => {
        const obj = gltf.scene;
        const offset = Array.isArray(c.offset)
          ? new THREE.Vector3().fromArray(c.offset)
          : null;
        let pos = new THREE.Vector3().fromArray(inst.position);
        if (offset) {
          pos.add(offset);
        } else {
          const boxEntry = institutionBoxes.find(b => b.id === inst.id);
          if (boxEntry) {
            const size = new THREE.Vector3();
            boxEntry.box.getSize(size);
            const off = new THREE.Vector3(size.x / 2 + 3, 0, 0);
            off.applyAxisAngle(new THREE.Vector3(0, 1, 0), inst.rotation || 0);
            pos.add(off);
          } else {
            pos.x += 3;
          }
        }

        obj.scale.setScalar(c.scale || inst.scale || 1);
        obj.rotation.y = inst.rotation || 0;
        scene.add(obj);
        const box = new THREE.Box3().setFromObject(obj);
        const ground = getGroundHeightAt(pos.x, pos.z);
        obj.position.set(pos.x, ground - box.min.y, pos.z);

        const cbox = new THREE.Box3().setFromObject(obj);
        constructionBoxes.push({ id: inst.id, index: idx, box: cbox });

        if (!constructionMap[inst.id][idx]) constructionMap[inst.id][idx] = {};
        if (c.status === 'scaffolding') {
          constructionMap[inst.id][idx].scaff = obj;
        } else {
          constructionMap[inst.id][idx].final = obj;
        }
      });
    });
  }

  function createInstitution(inst, animate) {
    const def = institutions.find(i => i.name === inst.name);
    if (!def) return;
    const loader = new GLTFLoader();
    loader.load(def.url, gltf => {
      const obj = gltf.scene;
      obj.scale.setScalar(inst.scale || def.scale || 1);
      obj.position.fromArray(inst.position);
      obj.rotation.y = inst.rotation || 0;
      scene.add(obj);
      institutionsMap[inst.id] = obj;
      const cons = inst.constructions || (inst.construction ? [inst.construction] : []);
      institutionDataMap[inst.id] = { ...inst, effects: def.effects, workforce: inst.workforce || [], extraEffects: inst.extraEffects || {}, constructions: cons };
      obj.traverse(o => { o.userData.institutionId = inst.id; });
      const box = new THREE.Box3().setFromObject(obj);
      institutionBoxes.push({ id: inst.id, box });
      applyConstruction(institutionDataMap[inst.id]);
      if (inst.owner === playerEmail) {
        if (def.effects) ownedInstitutions.push(def.effects);
        if (inst.extraEffects) ownedInstitutions.push(inst.extraEffects);
      }
      if (animate) {
        const startY = obj.position.y + 5;
        const endY = obj.position.y;
        obj.position.y = startY;
        sinking.push({ obj, start: startY, end: endY, t: 0, emit: 0 });
      }
    });
  }

  function showInstitutionPopup(id) {
    const popup = document.getElementById('institution-popup');
    const infoTabBtn = document.getElementById('info-tab-btn');
    const workforceTabBtn = document.getElementById('workforce-tab-btn');
    const chatTabBtn = document.getElementById('chat-tab-btn');
    const proposalsTabBtn = document.getElementById('proposals-tab-btn');
    const infoDiv = document.getElementById('popup-info');
    const workforceDiv = document.getElementById('popup-workforce');
    const chatDiv = document.getElementById('popup-chat');
    const proposalsDiv = document.getElementById('popup-proposals');
    const chatContainer = document.getElementById('chat-container');
    const ownerSpan = document.getElementById('popup-owner');
    const resDiv = document.getElementById('popup-resources');
    const closeBtn = document.getElementById('popup-close');

    let chatInterval = null;

    const instData = institutionDataMap[id];
    if (!instData) return;
    const isOwner = instData.owner === playerEmail;
    const def = institutions.find(i => i.name === instData.name);
    let count = 0;
    Object.values(institutionDataMap).forEach(d => {
      if (d.owner === instData.owner && d.name === instData.name) count++;
    });
    const effects = Object.assign({}, def.effects || {});
    if (instData.extraEffects) {
      for (const k of Object.keys(instData.extraEffects)) {
        effects[k] = (effects[k] || 0) + instData.extraEffects[k];
      }
    }
    const lines = [];
    Object.keys(effects).forEach(k => {
      lines.push(`${k}: +${effects[k]} (${(effects[k]*count).toFixed(2)} total)`);
    });
    resDiv.textContent = lines.join(' | ');
    const actionsDiv = popup.querySelector('.popup-actions');
    if (isOwner) {
      actionsDiv.style.display = 'flex';
      resDiv.style.display = 'block';
      ownerSpan.innerHTML = `Owner: <span id="owner-click" style="text-decoration:underline;cursor:pointer;">${instData.owner}</span>`;
    } else {
      actionsDiv.style.display = 'none';
      resDiv.style.display = 'none';
      ownerSpan.textContent = `Owner: ${instData.owner}`;
    }

    function showInfo() {
      infoDiv.style.display = 'block';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'none';
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      const carousel = document.getElementById('popup-workforce-carousel');
      carousel.innerHTML = '';
      const workers = [];
      Object.values(institutionDataMap).forEach(d => {
        if (d.owner === instData.owner && d.name === instData.name && Array.isArray(d.workforce)) {
          workers.push(...d.workforce);
        }
      });
      if (workers.length === 0) {
        carousel.textContent = 'No workforce';
        return;
      }
      workers.forEach(w => {
        const item = document.createElement('div');
        item.style.minWidth = '80px';
        item.style.display = 'flex';
        item.style.flexDirection = 'column';
        item.style.alignItems = 'center';
        const img = document.createElement('img');
        img.src = w.image;
        img.style.width = '60px';
        img.style.height = '80px';
        item.appendChild(img);
        const name = document.createElement('div');
        name.textContent = w.name + (w.director ? ' \u2605' : '');
        name.style.fontSize = '12px';
        item.appendChild(name);
        carousel.appendChild(item);
      });
    }

    async function showWorkforce() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'block';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'none';
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      const container = document.getElementById('workforce-container');
      // Immediately show loading spinner
      container.innerHTML = '<div class="spinner" style="display: flex; justify-content: center; align-items: center; height: 200px; color: #fff;">Loading applicants...</div>';

      try {
        const res = await fetch(`/api/workforce/generate/${id}`, { method: 'POST' });
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        const workersData = await res.json();

        // Clear loading and display workers
        container.innerHTML = '';

        if (!workersData.workers || workersData.workers.length === 0) {
          container.innerHTML = '<div style="color: #fff; text-align: center;">No applicants available</div>';
          return;
        }

        workersData.workers.forEach(w => {
          const card = document.createElement('div');
          card.className = 'worker-card';
          card.style.width = '150px';
          card.style.perspective = '800px';
          const inner = document.createElement('div');
          inner.className = 'card-inner';
          inner.style.position = 'relative';
          inner.style.width = '100%';
          inner.style.height = '200px';
          inner.style.transition = 'transform 0.6s';
          inner.style.transformStyle = 'preserve-3d';
          const front = document.createElement('div');
          front.style.position = 'absolute';
          front.style.backfaceVisibility = 'hidden';
          front.style.width = '100%';
          front.style.height = '100%';
          front.style.backgroundImage = `url(${w.image})`;
          front.style.backgroundSize = 'cover';
          front.style.backgroundPosition = 'center';
          front.textContent = w.name + (w.director ? ' \u2605' : '');
          front.style.display = 'flex';
          front.style.alignItems = 'flex-end';
          front.style.justifyContent = 'center';
          front.style.color = '#fff';
          front.style.textShadow = '0 1px 3px rgba(0,0,0,0.8)';
          front.style.padding = '8px';
          front.style.textAlign = 'center';
          front.style.fontSize = '14px';
          front.style.fontWeight = 'bold';
          const back = document.createElement('div');
          back.style.position = 'absolute';
          back.style.transform = 'rotateY(180deg)';
          back.style.backfaceVisibility = 'hidden';
          back.style.width = '100%';
          back.style.height = '100%';
          back.style.background = '#333';
          back.style.color = '#fff';
          back.style.fontSize = '12px';
          back.style.padding = '8px';
          back.style.overflowY = 'auto';
          back.style.boxSizing = 'border-box';
          back.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>${w.role}${w.director ? ' \u2605' : ''}</strong></div>
            <div style="margin-bottom: 8px; font-size: 11px;">${w.backstory}</div>
            <div style="margin-bottom: 8px; font-size: 11px;">${w.resume}</div>
            <div style="font-weight: bold;">Wage: $${w.wage}/day</div>
          `;
          inner.appendChild(front);
          inner.appendChild(back);
          card.appendChild(inner);
          card.onclick = () => {
            inner.style.transform = inner.style.transform === 'rotateY(180deg)' ? '' : 'rotateY(180deg)';
          };
          const hireBtn = document.createElement('button');
          hireBtn.textContent = 'Hire';
          hireBtn.style.width = '100%';
          hireBtn.style.marginTop = '20px';
          hireBtn.onclick = async (e) => {
            e.stopPropagation();
            try {
              const hireRes = await fetch(`/api/workforce/hire/${id}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ worker: w })
              });
              if (hireRes.ok) {
                if (!instData.workforce) instData.workforce = [];
                instData.workforce.push(w);
                container.removeChild(card);
                if (container.children.length === 0) {
                  container.innerHTML = '<div style="color: #fff; text-align: center;">All applicants hired!</div>';
                }
              } else {
                alert('Failed to hire worker');
              }
            } catch (err) {
              alert('Failed to hire worker');
            }
          };
          card.appendChild(hireBtn);
          container.appendChild(card);
        });
      } catch (err) {
        container.innerHTML = '<div style="color: #ff6666; text-align: center;">Failed to load applicants. Please try again.</div>';
      }
    }

    async function showChat() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'block';
      proposalsDiv.style.display = 'none';
      if (chatInterval) clearInterval(chatInterval);
      async function load() {
        try {
          const res = await fetch(`/api/workforce/chat/${instData.owner}/${instData.name}`);
          if (res.ok) {
            const data = await res.json();
            chatContainer.innerHTML = '';
            data.messages.forEach(m => {
              const box = document.createElement('div');
              box.className = 'chat-msg';
              let text = m.text;
              if (typeof m.text === 'object' && m.text !== null) {
                text = m.text.dialogue || '';
                if (m.text.is_proposal && m.text.proposal) {
                  const p = m.text.proposal;
                  const parts = [];
                  if (p.title) parts.push(`Title: ${p.title}`);
                  if (p.description) parts.push(`Description: ${p.description}`);
                  if (p.cost !== undefined) parts.push(`Cost: $${p.cost}`);
                  const info = parts.join(' | ');
                  if (info) text += ` (Proposal - ${info})`;
                }
              }
              box.textContent = `${m.worker}: ${text}`;
              chatContainer.appendChild(box);
              if (typeof m.text === 'object' && m.text !== null && m.text.raw) {
                const preRaw = document.createElement('pre');
                preRaw.className = 'chat-raw';
                preRaw.textContent = m.text.raw;
                chatContainer.appendChild(preRaw);
                if (m.text.proposal) {
                  const preObj = document.createElement('pre');
                  preObj.className = 'chat-raw';
                  preObj.textContent = JSON.stringify(m.text.proposal, null, 2);
                  chatContainer.appendChild(preObj);
                }
              }
            });
            chatContainer.scrollTop = chatContainer.scrollHeight;
          }
        } catch (err) {
        }
      }
      await load();
      chatInterval = setInterval(load, 5000);
    }

    async function showProposals() {
      infoDiv.style.display = 'none';
      workforceDiv.style.display = 'none';
      chatDiv.style.display = 'none';
      proposalsDiv.style.display = 'block';
      if (chatInterval) { clearInterval(chatInterval); chatInterval = null; }
      const container = document.getElementById('proposals-container');
      container.innerHTML = '<div class="spinner" style="height:100px;color:#fff">Loading...</div>';
      try {
        const res = await fetch(`/api/workforce/proposals/${id}`);
        const hist = await fetch(`/api/workforce/proposals/history/${id}`);
        if (res.ok && hist.ok) {
          const data = await res.json();
          const h = await hist.json();
          renderProposals(container, data.proposals || [], id, institutionDataMap, playerEmail, h.history || []);
        }
      } catch(err){
        container.innerHTML = '<div style="color:#ff6666">Failed</div>';
      }
    }

    if (isOwner) {
      infoTabBtn.onclick = showInfo;
      workforceTabBtn.onclick = showWorkforce;
      chatTabBtn.onclick = showChat;
      proposalsTabBtn.onclick = showProposals;
    } else {
      infoTabBtn.onclick = null;
      workforceTabBtn.onclick = null;
      chatTabBtn.onclick = null;
      proposalsTabBtn.onclick = null;
    }

    function closePopup() {
      popup.style.display = 'none';
      institutionPopupOpen = false;
      document.removeEventListener('keydown', escHandler);
      if (chatInterval) {
        clearInterval(chatInterval);
        chatInterval = null;
      }
      proposalsDiv.style.display = 'none';
    }

    function escHandler(e) {
      if (e.key === 'Escape') closePopup();
    }

    popup.style.display = 'block';
    institutionPopupOpen = true;
    showInfo();
    document.addEventListener('keydown', escHandler);
    closeBtn.onclick = closePopup;
    const ownerLink = document.getElementById('owner-click');
    if (ownerLink && isOwner) ownerLink.onclick = showWorkforce;
  }

  function updateSinking(dt) {
    for (let i = sinking.length - 1; i >= 0; i--) {
      const s = sinking[i];
      s.t += dt * 5;
      if (s.emit > 0.05 || s.t === 0) {
        emitDustParticle(s.obj.position, 5);
        s.emit = 0;
      }
      s.emit += dt;
      const t = Math.min(s.t, 1);
      s.obj.position.y = THREE.MathUtils.lerp(s.start, s.end, t);
      if (t >= 1) {
        sinking.splice(i, 1);
      }
    }
  }

  function updateInstitutionBoxes() {
    institutionBoxes.forEach(entry => {
      const obj = institutionsMap[entry.id];
      if (obj) entry.box.setFromObject(obj);
    });
  }

  function updateConstructionBoxes() {
    constructionBoxes.forEach(entry => {
      const list = constructionMap[entry.id];
      const c = list && list[entry.index];
      const obj = c && (c.scaff || c.final);
      if (obj) entry.box.setFromObject(obj);
    });
  }

  function handlePendingRemotePlayers() {
    if (!model) return;
    pendingRemotePlayers.forEach(p => createRemotePlayer(p.id, p.state));
    pendingRemotePlayers.length = 0;
  }

  function sendState() {
    if (!socket || socket.readyState !== WebSocket.OPEN || !model) return;
    socket.send(JSON.stringify({
      type: 'state',
      position: [model.position.x, model.position.y, model.position.z],
      rotation: model.rotation.y,
      moving: isMovingForward,
      health,
      hydration,
      oxygen,
      money: playerMoney
    }));
  }





  // Lighting
  const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x775533, 1.2);
  scene.add(hemiLight);

  // Main directional light (sun) - IMPROVED SHADOW SETTINGS
  const sun = new THREE.DirectionalLight(0xffffff, 1.8);
  sun.position.set(20, 30, 15);
  sun.castShadow = true;

  // Improved shadow quality
  sun.shadow.mapSize.width = 4096; // Increased from 2048
  sun.shadow.mapSize.height = 4096; // Increased from 2048
  sun.shadow.camera.near = 0.5;
  sun.shadow.camera.far = 200; // Extended range
  sun.shadow.camera.left = -100;
  sun.shadow.camera.right = 100;
  sun.shadow.camera.top = 100;
  sun.shadow.camera.bottom = -100;
  sun.shadow.bias = -0.0005; // Helps prevent shadow acne

  scene.add(sun);

  // Uncomment to visualize shadow camera (helpful for debugging)
  // const helper = new THREE.CameraHelper(sun.shadow.camera);
  // scene.add(helper);

  // Additional directional light for better terrain illumination
  const secondaryLight = new THREE.DirectionalLight(0xffd6a5, 1.0); // Warm light
  secondaryLight.position.set(-15, 20, -10); // From opposite direction of sun
  secondaryLight.castShadow = false; // Optional shadow from secondary light
  scene.add(secondaryLight);

  // Ground Textures - Load first before terrain
  const textureLoader = new THREE.TextureLoader();
  let diffuseMap = null;
  let bumpMap = null;
  let specMap = null;
  const baseTextureRepeat = 1000; // Base repeat factor for the texture

  // Track texture loading status
  const texturesLoaded = {
    diffuse: false,
    bump: false,
    spec: false
  };

  // Function to check if all textures are loaded and apply them
  function checkTexturesAndApply() {
    if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
      if (gltfTerrain) {
        applyTexturesToTerrain(gltfTerrain);
      }
    }
  }

  // Load diffuse texture (base color)
  textureLoader.load(
    'mars_ground.png',
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      diffuseMap = texture;
      texturesLoaded.diffuse = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.diffuse = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load bump map
  textureLoader.load(
    'mars_ground_bump.png', // Adjust filename to match your bump map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      bumpMap = texture;
      texturesLoaded.bump = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.bump = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load specular map
  textureLoader.load(
    'mars_ground_spec.png', // Adjust filename to match your specular map
    (texture) => {
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(baseTextureRepeat, baseTextureRepeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      specMap = texture;
      texturesLoaded.spec = true;

      checkTexturesAndApply();
    },
    undefined,
    (error) => {
      texturesLoaded.spec = true; // Mark as done even if error
      checkTexturesAndApply();
    }
  );

  // Load dust particle texture
  let dustTexture;
  textureLoader.load(
    'dust.png',
    (texture) => {
      dustTexture = texture;
      // Initialize dust particles system once texture is loaded
      initDustParticles();
    },
    undefined,
    (error) => {
      // Create a fallback texture - a simple circle
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 24;

      // Draw a simple radial gradient for the particle
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
      gradient.addColorStop(0, 'rgba(255, 230, 200, 1.0)');
      gradient.addColorStop(0.5, 'rgba(230, 200, 170, 0.5)');
      gradient.addColorStop(1, 'rgba(200, 170, 140, 0.0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();

      dustTexture = new THREE.CanvasTexture(canvas);
      initDustParticles();
    }
  );

  // Helper function to apply textures to terrain
  function applyTexturesToTerrain(terrain) {
    terrain.traverse(o => {
      if (o.isMesh) {
        // Create a new material with all textures
        o.material = new THREE.MeshStandardMaterial({
          map: diffuseMap,
          bumpMap: bumpMap,
          bumpScale: 2.3, // Adjust bump intensity
          roughnessMap: specMap, // In PBR, specular is controlled by roughness
          roughness: 5,
          metalness: 0.0,
          color: 0xDC916E // White color to allow texture to show properly
        });
        o.receiveShadow = true; // Make sure terrain receives shadows
        o.material.needsUpdate = true;
      }
    });
  }

  // --- DUST PARTICLES SYSTEM ---
  const MAX_PARTICLES = 300;
  let particleSystem;
  let dustParticles = []; // Array of active particles

  function initDustParticles() {

    // Create a simple points material using the dust texture
    const particleMaterial = new THREE.PointsMaterial({
      size: 1.0,
      map: dustTexture,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      transparent: true,
      opacity: 0.6,
      sizeAttenuation: true,
      color: 0xbbaa99 // Dusty color
    });

    // Create geometry for the particles
    const particlesGeometry = new THREE.BufferGeometry();

    // Create arrays for positions, sizes, and colors
    const positions = new Float32Array(MAX_PARTICLES * 3);
    const sizes = new Float32Array(MAX_PARTICLES);
    const colors = new Float32Array(MAX_PARTICLES * 3);

    // Initialize all particles to be far below the scene (inactive)
    for (let i = 0; i < MAX_PARTICLES; i++) {
      positions[i * 3] = 0;
      positions[i * 3 + 1] = -1000; // Far below the scene
      positions[i * 3 + 2] = 0;

      sizes[i] = 0;

      // Slightly vary the color of each particle
      const dustColor = new THREE.Color(0xbbaa99);
      dustColor.r *= 0.8 + Math.random() * 0.4;
      dustColor.g *= 0.8 + Math.random() * 0.4;
      dustColor.b *= 0.8 + Math.random() * 0.4;

      colors[i * 3] = dustColor.r;
      colors[i * 3 + 1] = dustColor.g;
      colors[i * 3 + 2] = dustColor.b;

      // Create particle object
      dustParticles.push({
        position: new THREE.Vector3(0, -1000, 0),
        velocity: new THREE.Vector3(0, 0, 0),
        size: 0,
        color: dustColor,
        life: 0,
        maxLife: 2.0,
        active: false,
        index: i
      });
    }

    // Add attributes to the buffer geometry
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create the particle system
    particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    particleSystem.frustumCulled = false; // Prevent particles from disappearing at edge of view
    scene.add(particleSystem);

  }

  // Create new active particles
  function emitDustParticle(position, count = 5) {
    if (!particleSystem) {
      return;
    }

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;

    let emitted = 0;

    // Find inactive particles to reuse
    for (let i = 0; i < dustParticles.length && emitted < count; i++) {
      const particle = dustParticles[i];

      if (!particle.active) {
        // Random offset around the foot position
        const offsetX = (Math.random() - 0.5) * 0.8;
        const offsetZ = (Math.random() - 0.5) * 0.8;

        // Position the particle slightly above ground level
        particle.position.set(
          position.x + offsetX,
          position.y + 0.1, // Higher above ground for visibility
          position.z + offsetZ
        );

        // Random velocity
        particle.velocity.set(
          (Math.random() - 0.5) * 0.6, // More horizontal spread
          Math.random() * 0.5 + 0.2,   // More vertical rise
          (Math.random() - 0.5) * 0.6  // More horizontal spread
        );

        particle.maxLife = 1.0 + Math.random() * 1.5; // 1.0-2.5 seconds
        particle.life = 0;
        particle.size = 0.5;  // Starting size (larger for better visibility)
        particle.active = true;

        // Update the particle data in the buffers
        const idx = particle.index;
        positions[idx * 3] = particle.position.x;
        positions[idx * 3 + 1] = particle.position.y;
        positions[idx * 3 + 2] = particle.position.z;

        sizes[idx] = particle.size;

        emitted++;
      }
    }

    // Mark attributes as needing update
    particleSystem.geometry.attributes.position.needsUpdate = true;
    particleSystem.geometry.attributes.size.needsUpdate = true;

  }

  // Update particles every frame
  function updateParticles(dt) {
    if (!particleSystem) return;

    const positions = particleSystem.geometry.attributes.position.array;
    const sizes = particleSystem.geometry.attributes.size.array;
    let needsUpdate = false;

    // Update each active particle
    for (let i = 0; i < dustParticles.length; i++) {
      const particle = dustParticles[i];

      if (particle.active) {
        // Update particle life
        particle.life += dt;

        if (particle.life >= particle.maxLife) {
          // Deactivate the particle
          particle.active = false;

          // Move it far below scene
          particle.position.y = -1000;
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          sizes[i] = 0;
          needsUpdate = true;
        } else {
          // Calculate life progress (0 to 1)
          const t = particle.life / particle.maxLife;

          // Update position with velocity
          particle.position.x += particle.velocity.x * dt;
          particle.position.y += particle.velocity.y * dt;
          particle.position.z += particle.velocity.z * dt;

          // Air resistance / drag
          particle.velocity.multiplyScalar(0.95);

          // Gravity effect - slow down ascent
          particle.velocity.y -= 0.1 * dt;

          // Calculate size and opacity based on life cycle
          // Start small, grow, then shrink
          let size;
          if (t < 0.2) {
            // Grow quickly at start
            size = (t / 0.2) * 2.0;
          } else if (t > 0.8) {
            // Shrink at end
            size = 2.0 * (1.0 - (t - 0.8) / 0.2);
          } else {
            // Maintain size in middle
            size = 2.0;
          }

          // Update size (larger and more visible)
          particle.size = size;
          sizes[i] = size;

          // Update position in buffer
          positions[i * 3] = particle.position.x;
          positions[i * 3 + 1] = particle.position.y;
          positions[i * 3 + 2] = particle.position.z;

          needsUpdate = true;
        }
      }
    }

    // Only update buffers if needed
    if (needsUpdate) {
      particleSystem.geometry.attributes.position.needsUpdate = true;
      particleSystem.geometry.attributes.size.needsUpdate = true;
    }
  }

  // --- PHYSICS AND GRAVITY SETTINGS ---
  const gravity = 3.7; // Mars gravity (lower than Earth's 9.8)
  const groundCheckDistance = 2.0; // Slightly increased for stability
  let velocity = new THREE.Vector3(0, 0, 0);
  let onGround = false;
  let groundY = null; // To track stable ground height
  const groundDamping = 1; // Dampening factor (0.0 to 1.0) - higher means less bounce
  const initialFallHeight = 100; // Reasonable height to start falling from

  // Raycaster for ground detection
  const raycaster = new THREE.Raycaster();

  // --- LOAD GLTF GROUND MODEL ---
  const groundLoader = new GLTFLoader();
  let gltfTerrain;
  const terrainScaleFactor = 50; // Adjust this to scale your terrain

  // Array to store all terrain meshes for raycasting
  const terrainMeshes = [];

  groundLoader.load(
    'terrain.gltf', // Replace this with the path to your ground GLTF file
    (gltf) => {
      gltfTerrain = gltf.scene;

      gltfTerrain.scale.set(terrainScaleFactor, terrainScaleFactor, terrainScaleFactor);

      // Optional: Adjust terrain position if needed
      // gltfTerrain.position.y = -someValueToCorrect;

      gltfTerrain.traverse(o => {
        if (o.isMesh) {
          o.receiveShadow = true;
          o.castShadow = false;

          // Add mesh to our array for raycasting
          terrainMeshes.push(o);
        }
      });

      // Apply textures if they're already loaded
      if (texturesLoaded.diffuse && texturesLoaded.bump && texturesLoaded.spec) {
        applyTexturesToTerrain(gltfTerrain);
      }

      scene.add(gltfTerrain);

      // Position model on the terrain if it's already loaded
      if (model) {
        findGroundBelow();
      }
    },
    undefined,
    (error) => {
      // Create a fallback terrain with some hills
      createFallbackTerrain();
    }
  );

  // Create a fallback procedural terrain with variation for testing
  function createFallbackTerrain() {
    // Create a larger, more detailed fallback ground with some hills
    const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);

    // Add some hills and valleys
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
      // Skip the edges to keep them flat
      const x = vertices[i];
      const z = vertices[i+2];
      if (Math.abs(x) < 90 && Math.abs(z) < 90) {
        // Create some hills using sine waves
        vertices[i+1] = Math.sin(x * 0.1) * 3 + Math.sin(z * 0.1) * 3;
      }
    }

    // Important: update normals after modifying vertices
    groundGeometry.computeVertexNormals();

    // Create material with available textures
    const groundMaterial = new THREE.MeshStandardMaterial({
      roughness: 0.8,
      metalness: 0.2
    });

    // Apply textures to fallback terrain if available
    if (diffuseMap) {
      groundMaterial.map = diffuseMap;
      groundMaterial.map.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    } else {
      groundMaterial.color.set(0x553311);
    }

    if (bumpMap) {
      groundMaterial.bumpMap = bumpMap;
      groundMaterial.bumpScale = 0.5;
      groundMaterial.bumpMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    if (specMap) {
      groundMaterial.roughnessMap = specMap;
      groundMaterial.roughnessMap.repeat.set(baseTextureRepeat * 0.5, baseTextureRepeat * 0.5);
    }

    const fallbackGround = new THREE.Mesh(groundGeometry, groundMaterial);
    fallbackGround.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    fallbackGround.receiveShadow = true;
    scene.add(fallbackGround);

    // Add to terrainMeshes for raycasting
    terrainMeshes.push(fallbackGround);


    // Position the model if it's already loaded
    if (model) {
      findGroundBelow();
    }
  }

  // Player model and animations
  let model, mixer;
  let runAction, idleAction;
  let activeAction;
  const modelScale = 1.2;
  const characterHeight = 1.8 * modelScale; // Approximate height of character
  let playerAnimations = null;

  // Track foot positions for dust particles
  const footPositions = {
    left: new THREE.Vector3(),
    right: new THREE.Vector3(),
    lastEmitTime: 0
  };

  // Load player model
  new GLTFLoader().load(
    'https://threejs.org/examples/models/gltf/Soldier.glb',
    gltf => {
      model = gltf.scene;
      model.scale.set(modelScale, modelScale, modelScale);
      model.rotation.y = 0; // Initial forward direction

      // Setup shadow casting
      model.traverse(o => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = false;
        }
      });
      scene.add(model);

      // Position the model based on saved state
      model.position.set(startPosition[0], startPosition[1], startPosition[2]);

      // Setup animations
      mixer = new THREE.AnimationMixer(model);
      const animations = gltf.animations;
      idleAction = mixer.clipAction(animations.find(a => a.name === 'Idle'));
      runAction = mixer.clipAction(animations.find(a => a.name === 'Run'));
      playerAnimations = animations;


      // Set up animation events for dust particles
      if (runAction) {
        // Add an event that fires at specific points in animation
        // (these numbers would need adjustment based on the actual animation)
        const leftFootStep = 0.3; // 30% through animation
        const rightFootStep = 0.8; // 80% through animation

        // Set up animation events using mixer
        mixer.addEventListener('loop', function(e) {
          if (e.action === runAction && isMovingForward && onGround) {
            // Calculate foot positions and emit dust at each step
            calculateFootPositions();
          }
        });
      }

      activeAction = idleAction || runAction;
      if (activeAction) activeAction.play();

      // If terrain is already loaded, we can find the ground
      if (terrainMeshes.length > 0) {
        findGroundBelow();
      }
      handlePendingRemotePlayers();
    },
    undefined,
  );

  // Calculate foot positions based on model
  function calculateFootPositions() {
    if (!model) return;

    // Get model's world position
    const modelPosition = model.position.clone();
    const modelDirection = new THREE.Vector3(0, 0, -1);
    modelDirection.applyQuaternion(model.quaternion);

    // Calculate basic foot positions (slightly behind model for walking)
    // This is an approximation - would be better with actual bone positions
    const footOffset = 0.5 * modelScale;

    // Position for left foot
    footPositions.left.set(
      modelPosition.x - modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z + modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Position for right foot
    footPositions.right.set(
      modelPosition.x + modelDirection.z * footOffset * 0.5, // perpendicular to direction
      modelPosition.y,
      modelPosition.z - modelDirection.x * footOffset * 0.5  // perpendicular to direction
    );

    // Emit particles at both feet
    emitDustParticle(footPositions.left, 10); // Emit more particles for better visibility
    emitDustParticle(footPositions.right, 10);

  }

  /**
   * Finds the ground below the character without teleporting to it
   * Just identifies where the ground is for physics to work with
   */
  function findGroundBelow() {
    if (!model || terrainMeshes.length === 0) return;

    // Use the actual current position of the model
    const origin = model.position.clone();

    // Cast ray downward from current position
    raycaster.set(
      origin,
      new THREE.Vector3(0, -1, 0) // Direction straight down
    );

    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    if (intersects.length > 0) {
      // We found ground - but we won't teleport to it
      // Just let gravity do its work in the animation loop

      // We're not on ground yet - we're still falling
      onGround = false;
    } else {
    }
  }

  // Input state
  const keys = { w: false, a: false, s: false, d: false, arrowup: false, arrowleft: false, arrowright: false, arrowdown: false, space: false };
  window.addEventListener('keydown', e => {
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = true;
  });
  window.addEventListener('keyup', e => {
    const key = e.code.toLowerCase().replace('key', '').replace('arrow','');
    if (keys.hasOwnProperty(key)) keys[key] = false;
  });

  // Camera and movement settings
  const camOffset = new THREE.Vector3(0, 2.0 * modelScale, 5.0 * modelScale);
  const modelLookAtHeight = 1.5 * modelScale;
  const clock = new THREE.Clock();
  let isMovingForward = false;
  let lastPosition = new THREE.Vector3();
  let timeSinceLastEmit = 0;

  function switchAnimation(actionToPlay) {
    if (activeAction === actionToPlay || !actionToPlay) return;
    if (activeAction) activeAction.fadeOut(0.2);
    actionToPlay.reset().fadeIn(0.2).play();
    activeAction = actionToPlay;
  }

  /**
   * Checks if character is in contact with the ground
   * Called every frame in the animation loop
   */
  function checkGroundContact() {
    if (!model) return;

    // Origin is at character's feet plus half height (center of character)
    const origin = model.position.clone();
    origin.y += characterHeight / 2;

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    // Check if we're on or near ground
    if (intersects.length > 0 && intersects[0].distance <= groundCheckDistance) {
      const groundPosition = intersects[0].point.y;

      // Handle initial ground contact
      if (!onGround) {
          velocity.y = 0;
          onGround = true;

      } else {
        // Already on ground - stabilize position with smooth interpolation
        if (groundY === null) {
          groundY = groundPosition;
        } else {
          // Smoothly interpolate ground height to prevent jitter
          groundY = groundY * 0.9 + groundPosition * 0.1;
        }

        // Smoothly set character position
        model.position.y = groundY;
        velocity.y = 0;
      }
    } else {
      // Not touching ground
      onGround = false;
      groundY = null;
    }
  }

  // Update alignment with terrain after horizontal movement
  function updateTerrainAlignment() {
    if (!model) return;

    // Only check terrain alignment if we're on the ground
    if (!onGround) return;

    // Origin at character's feet
    const origin = model.position.clone();
    origin.y += 0.5 * characterHeight; // Start from middle of character

    // Cast ray downward
    raycaster.set(origin, new THREE.Vector3(0, -1, 0));
    const intersects = raycaster.intersectObjects(terrainMeshes, true);

    if (intersects.length > 0) {
      const targetY = intersects[0].point.y;

      // Smooth interpolation of height change for walking on uneven terrain
      if (groundY === null) {
        groundY = targetY;
      } else {
        // Adjust smoothing factor based on how fast we're moving
        // More smoothing (smaller factor) for faster movement to reduce jitter
        const smoothFactor = isMovingForward ? 0.15 : 0.3;
        groundY = groundY * (1 - smoothFactor) + targetY * smoothFactor;
      }

      // Apply smoothed position
      model.position.y = groundY;
    }
  }

  function updateCamera(dt) {
    if (!model) return;

    const modelWorldPosition = new THREE.Vector3();
    model.getWorldPosition(modelWorldPosition);

    // Apply camera offset in model's local space
    const desiredCamPos = modelWorldPosition.clone().add(
      camOffset.clone().applyQuaternion(model.quaternion)
    );

    // Smoother camera lerp
    camera.position.lerp(desiredCamPos, 5 * dt);

    // Look at point slightly above character's feet
    const lookAtPoint = modelWorldPosition.clone();
    lookAtPoint.y += modelLookAtHeight;
    camera.lookAt(lookAtPoint);
  }

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    // Update particles
    updateParticles(dt);
    updateSinking(dt);
    updateInstitutionBoxes();
    updateConstructionBoxes();

    if (mixer) mixer.update(dt);
    for (const id in remotePlayers) {
      remotePlayers[id].mixer.update(dt);
    }

    if (model && terrainMeshes.length > 0) {
        // PHYSICS - Apply gravity if not on ground
        if (!onGround) {
            velocity.y -= gravity * dt;

            // Apply velocity (for falling)
            model.position.y += velocity.y * dt;

            // Force idle animation when in the air
            if (idleAction && activeAction !== idleAction) {
                switchAnimation(idleAction);
                // We're not moving forward when in the air
                isMovingForward = false;
            }
        }

        // Check if on ground after applying gravity
        checkGroundContact();

        // Controls and movement - only process when on ground
        if ((idleAction || runAction) && onGround) {
            // Save last position for movement detection
            lastPosition.copy(model.position);

            const speed = 5.0 * modelScale;
            const turnSpeed = (Math.PI); // Adjusted turn speed a bit

            let wantsToMoveForward = keys.w || keys.up;
            let wantsToMoveBackward = keys.s || keys.down;
            let turnLeft = keys.a || keys.left;
            let turnRight = keys.d || keys.right;

            // Handle turning
            if (turnLeft) model.rotation.y += turnSpeed * dt;
            if (turnRight) model.rotation.y -= turnSpeed * dt;

            // Movement
            let moving = false;
            let moveDir = new THREE.Vector3(0, 0, 0);

            if (wantsToMoveForward) {
                // Fixed direction to go forward from model perspective
                moveDir.z = -1;
                moving = true;
            } else if (wantsToMoveBackward) {
                moveDir.z = 0.5;
                moving = true;
            }

            // Apply movement in model's local direction
            if (moving) {
                // Switch to running animation if not already
                if (!isMovingForward && runAction) {
                    switchAnimation(runAction);
                    isMovingForward = true;
                }

                // Transform direction to world space
                moveDir.applyQuaternion(model.quaternion);
                moveDir.normalize();

                // Store current position before movement
                const oldPos = model.position.clone();

                const proposed = model.position.clone().add(moveDir.clone().multiplyScalar(speed * dt));
                let blocked = false;
                const sphere = new THREE.Sphere(proposed, 1);
                institutionBoxes.forEach(entry => {
                    if (entry.box.intersectsSphere(sphere)) blocked = true;
                });
                constructionBoxes.forEach(entry => {
                    if (entry.box.intersectsSphere(sphere)) blocked = true;
                });
                if (!blocked) {
                    model.position.copy(proposed);
                }

                // Update terrain alignment after horizontal movement
                if (onGround) {
                    updateTerrainAlignment();

                    // Emit dust particles when walking on ground
                    timeSinceLastEmit += dt;
                    if (timeSinceLastEmit > 0.1) { // More frequent emission (was 0.2)
                        calculateFootPositions();
                        timeSinceLastEmit = 0;

                        // Debug log for dust emission
                        if (isMovingForward && onGround) {
                        }
                    }
                }
            } else if (isMovingForward && idleAction) {
                // Switch to idle when not moving
                switchAnimation(idleAction);
                isMovingForward = false;
            }
        }

        if (model.position.y < -100) {
          model.position.y = 60;
          velocity.y = 0;
          groundY = null;
          onGround = false;
        }

        // Camera follow
        updateCamera(dt);
        updateGhostInstitution();
        if (!dead) {
          sendState();
          updateStats();
          institutionFrame++;
          if (institutionFrame >= INSTITUTION_INTERVAL_FRAMES) {
            applyInstitutionEffects();
            institutionFrame = 0;
          }
        }
        else {
          sendState();
        }
    }

    // Debug rendering to visualize particle positions
    if (particleSystem && particleSystem.geometry) {
      const positions = particleSystem.geometry.attributes.position.array;
      const sizes = particleSystem.geometry.attributes.size.array;

      // Count active particles
      let activeCount = 0;
      for (let i = 0; i < dustParticles.length; i++) {
        if (dustParticles[i].active) activeCount++;
      }

      if (activeCount > 0 && model) {
      }
    }

    // Render using composer for bloom effect
    composer.render();
}

  animate();

  // Resize handler
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);

    // Update bloom pass resolution
    bloomPass.resolution.set(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>